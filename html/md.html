<!DOCTYPE HTML>
<HTML lang="es">
  <HEAD>
    <META HTTP-EQUIV="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    
    <LINK rel="stylesheet" type="text/css" href="https://elisa.dyndns-web.com/teaching/curso.css">


    <TITLE>Matem&aacute;ticas Discretas &mdash; Schaeffer</title>
    <script type="text/javascript"
    src="https://elisa.dyndns-web.com/scripts/syntax/scripts/shCore.js"></script>
    <script type="text/javascript"
    src="https://elisa.dyndns-web.com/scripts/syntax/scripts/shBrushPython.js"></script>
    <link type="text/css" rel="stylesheet"
	  href="https://elisa.dyndns-web.com/scripts/syntax/styles/shThemeEmacs.css"/>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
  </HEAD>
  <BODY>
    <div id="elementos">  
      <div id="navibar">
	<p>
	  <a href="https://elisa.dyndns-web.com">Schaeffer</a> /
	  <a href="https://elisa.dyndns-web.com/teaching/mat/discretas/">Curso</a> 
	  / Matem&aacute;ticas Discretas
	</p>
      </div>
      <div class="contenido">
	<h1>Matem&aacute;ticas Discretas<br><small>Curso en l&iacute;nea</small></h1>
	<div id="login"></div>
	<div id="debug"></div>
	<div id="intro">
	  <p>
	    Este sitio web provee una gu&iacute;a con ejercicios para
	    aprender matem&aacute;ticas discretas. No es factible
	    intentar aprender esto solamente por leer este sitio web
	    sino es necesario apoyarse con un libro de texto; la
	    biblioteca de la FIME tiene algunos libros &uacute;tiles
	    (incluyendo la de posgrado). Para recibir una
	    formaci&oacute;n de nivel internacional en &aacute;reas
	    relacionadas a la computaci&oacute;n, recomiendo mucho el
	    libro
	    <a target="_blank" href="http://www.amazon.es/Concrete-Mathematics-Foundation-Computer-Science/dp/0201558025">Concrete
	      Mathematics</a>; se menciona en esta p&aacute;gina
	      cuando hay un cap&iacute;tulo o una secci&oacute;n de
	      ese libro que convendr&iacute;a estudiar para
	      profundizar un tema. 
	    </p>
	  <p>
	    Otro libro altamente recomendable que tambi&eacute;n existe
	    <a target="_blank" href="https://books.google.com.mx/books?id=lHqqjoR0b1YC&printsec=frontcover&hl=es&redir_esc=y#v=onepage&q&f=false">traducido
	      al espa&ntilde;ol</a> es &eacute;l de Grimaldi,
	    <a target="_blank" href="http://www.amazon.com/Discrete-Combinatorial-Mathematics-Applied-Introduction/dp/0201726343">Discrete
	      and Combinatorial Mathematics: An Applied Introduction</a>; los
	    n&uacute;meros de cap&iacute;tulos y secciones que menciono son los de
	    la tercera edici&oacute;n en espa&ntilde;ol, pero usando un
	    &iacute;ndice tem&aacute;tico deber&iacute;an poder ubicar todo en
	    otras ediciones o en el original en ingl&eacute;s sin problema. Tiene
	    ejemplos muy simples y concretos de todos los conceptos, facilitando
	    la vida para los que a&uacute;n no llegan a una capacidad de
	    abstracci&oacute;n suficiente para sentirse iluminados viendo
	    ecuaciones y definiciones.  Este libro de texto us&eacute; yo como
	    estudiante en la universidad &mdash; matem&aacute;ticas discretas fue
	    mi tema favorito de todo en plan de estudios. La biblio debe tenerla,
	    les don&eacute; un ejemplar yo misma en junio del 2015 (junto con un
	    ejemplar de Concrete Mathematics, que probablemente termina en la
	    biblio de posgrado &mdash; busquen siempre en ambas).
	  </p>
	  <p>
	    Es necesario leer el libro de texto para comprender los
	    temas de la unidad de aprendizaje de una manera
	    adecuada. M&iacute;nimo lean Wikipedia si la hueva no les
	    permite estudiar de una forma m&aacute;s
	    rigurosa. <strong>Leer solamente esta p&aacute;gina no
	    basta</strong>; es simplemente un resumen y una forma de
	    establecer notaci&oacute;n y terminolog&iacute;a para nuestro uso ya que
	    eso siempre var&iacute;a entre libros y herramientas. Si lectura
	    no es lo suyo, vean videos o algo.
	  </p>
	  <p>
	    Para experimentar con los conceptos, se utiliza como
	    herramienta computacional el lenguaje
	    <strong>Python</strong> en su versi&oacute;n 3.  Para
	    instalarlo en una computadora, visita a
	    <a href="https://www.python.org/download">https://www.python.org/download</a>
	    y sigue las instrucciones.
	  </p>
	  <p>
	    Revisa tus respuestas a las tareas con cuidado antes de
	    proceder a calificarlas. Ven a clase a consultar con la
	    profesora si tienes dudas.
	  </p>
	</div>
	<div class="menu">
	  <h3>Temas</h3>
	  <ul>
	    <li><a href="#logi">L&oacute;gica</a> (U1)</li>
	    <li><a href="#comb">Combinatoria</a> (U2)</li>
	    <li><a href="#graf">Grafos y &aacute;rboles</a> (U3)</li>
	    <li><a href="#prob">Problemas y algoritmos</a> (U3)</li>
	  </ul>
	</div>
	<div class="menu">
	  <h3>Tareas</h3>
	  <span id="pts"></span>
	  <ul>
	    <li><a href="#e1">Tarea 1</a> <span id="p1"></span></li>
	    <li><a href="#e2">Tarea 2</a> <span id="p2"></span></li>
	    <li><a href="#e3">Tarea 3</a> <span id="p3"></span></li>
	    <li><a href="#e4">Tarea 4</a> <span id="p4"></span></li>
	    <li><a href="#e5">Tarea 5</a> <span id="p5"></span></li>
	  </ul>
	</div>
	<div class="unidad">
	  <h2 id="logi">L&oacute;gica</h2>
	  <div class="clase">
	    <h3>Fundamentos</h3>
	    <p>
	      Para comenzar, es necesario aprender operaciones b&aacute;sicas de
	      <strong>aritm&eacute;tica entera</strong> en Python (es
	      decir, operaciones que toman como entrada n&uacute;meros
	      enteros y producen como salida n&uacute;meros enteros):
	      suma, resta, producto, potencia, divisi&oacute;n entera,
	      residuo (m&oacute;dulo, discutido en la secci&oacute;n
	      3.4 de Concrete Mathematics). Prueba siempre todas las
	      instrucciones de Python de los ejemplos hasta que
	      est&eacute;s seguro de entender exactamente qu&eacute;
	      es el efecto de cada instrucci&oacute;n.
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
3 + 5 # suma
9 - 3 # resta
4 * 6 # multiplicaci&oacute;n
2 ** 3 # dos elevado a la potencia tres
a = 1234567 # guardamos un valor espec&iacute;fico 
b = 17 # guardamos otro valor
a // b # cuantas veces b cabe en a
a % b # cuanto es el residuo
a % b == 0 # si a es divisible entre b
]]></script>
	    <p>
	      Tambi&eacute;n existe la aritm&eacute;tica donde
	      los todos operandos y/o resultados <em>no</em> son enteros.
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
3.7 + 5 
9 - 3.6
4 * 2.6
2.4 ** 0.4
8 / 3
]]></script>
	    <p>
	    Adem&aacute;s de n&uacute;meros, en Python se puede
	    manipular <strong>cadenas</strong> (de texto):
	    </p>
	    <ul>
	      <li>Definici&oacute;n con comillas (simples o dobles, no importa).</li>
	      <li>Concatenaci&oacute;n con <span class="codevar">+</span>.</li>
	      <li>Repetici&oacute;n con <span class="codevar">*</span>.</li>
	      <li>Caracteres con acento <em>no</em> causan problemas en Python.</li>
	    </ul>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
"hola"
'hola'
"hola" + 'mundo'
'hola' * 3
'qu&eacute;'
]]></script>
	    <p>
	    Valores se pueden guardar en <strong>variables</strong>:
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
a = 3
b = 'prueba'
c = 5.434
]]></script>
	    <p>
	    Los valores guardados se pueden <em>imprimir</em>:
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
print(a)
print(a, b)
nombre = 'elisa'
print('hola, {:s}'.format(nombre))
from math import pi
pi
print('pi vale {:f}'.format(pi))
print(f'pi vale {pi}') # manera breve
]]></script>
	    <p>
	      Aqu&iacute; <span class="codevar">math</span> es una
	      librer&iacute;a de rutinas matem&aacute;ticas
	      adicionales, de la cual se est&aacute; importando al
	      programa una constante
	      llamada <span class="codevar">pi</span>. Lo
	      de <span class="codevar">{:s}</span> es un "separador de
	      lugar" para imprimir en esa posici&oacute;n el valor de
	      una cadena, mientras <span class="codevar">{:f}</span>
	      es para un valor con lugares decimales (no entero)
	      y <span class="codevar">{:d}</span> ser&iacute;a para un
	      entero.
	    </p>
	    </div>
<div class="clase">
	    <h3>Notaci&oacute;n matem&aacute;tica</h3>
	    <p>
	      Hay varios s&iacute;mbolos cuyo significado se debe conocer para
	      poder interpretar adecuadamente ecuaciones y definiciones en
	      cualquier campo de las matem&aacute;ticas. Primeramente, la
	      notaci&oacute;n $x \Rightarrow y$ significa que si aplica $x$,
	      tambi&eacute;n aplica $y$; a esto se le llama "implicaci&oacute;n"
	      y se profundiza la discusi&oacute;n m&aacute;s adelante en este
	      curso sobre su significado formal.
	    </p>
	    <p>
	      Notaciones tipo $(a, b), (a, b], [a, b), [a, b]$ refieren
	      a <em>intervalos</em> (discretos o continuos); un
	      par&eacute;ntesis implica que el valor extremo no
	      pertenece al intervalo, mientras un corchete indica que
	      tambi&eacute;n pertenece.
	    </p>
	    <h4>Fundamentos de conjuntos</h4>
	    <p>
	      Antes que nada, hay que aclarar la notaci&oacute;n y
	      terminolog&iacute;a referente a <em>conjuntos</em>.
	      Conjuntos son el tema del cap&iacute;tulo 3 de
	      Grimaldi. Los conjuntos frecuentemente se representan
	      visualmente con <em>diagramas de Venn</em>, tratados en
	      la secci&oacute;n 3.3 de Grimaldi.
	    </p>
	    <img src="img/venn.png" width=200 alt="Un diagrama e Venn">
	    <ul>
	      <li>$A = \{a, b, c\}$ es un conjunto con tres elementos.</li>
	      <li>Se escribe $\sum_{i \in A}$ para la <strong>suma</strong> sobre
		todos los elementos de un conjunto $A$.</li>
	      <li>Se escribe $\prod_{i \in A}$ para
		el <strong>producto</strong> sobre todos los elementos
		de un conjunto $A$.</li>
	      <li>$|A|$ es la <em>cardinalidad</em> (es decir, el
		tama&ntilde;o).</li>
	      <li>Se escribe $\in$ para indicar pertenencia de un
		elemento a un conjunto: $a \in A$.</li>
	      <li>$a \notin A$ significa que $a$ no pertenece a $A$.</li>
	    </ul>
<p>
Si tienes dudas sobre el comportamiento de sumas y productos, repasa
leyendo la secci&oacute;n 1.1 de Grimaldi.
</p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
A = {'a', 'b', 'c'} # un conjunto
len(A) # su cardinalidad
'a' in A # comprobar pertenencia
'd' in A
'b' not in A # comprobar que no pertenezca
'e' not in A
]]></script>
	    <p>
	      Por ejemplo, $\mathbb{Z}$ (enteros) y $\mathbb{R}$ (reales) son
	      conjuntos de cardinalidad infinita, mientras $\emptyset$
	      es el conjunto vac&iacute;o que no contiene
	      ning&uacute;n elemento.
	    </p>
	    <ul>
	      <li>$A \cup B$ es la <em>uni&oacute;n</em> de dos conjuntos.</li>
	      <li>$A \cap B$ es la <em>intersecci&oacute;n</em> de dos conjuntos.</li>
	      <li>$A \setminus B = \{a \mid a \in A, a \notin B\}$ es la <em>diferencia</em>.</li>
	    </ul>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
A = {1, 2, 3}
B = {'x', 'y', 'z'}
A.union(B)
A | B # lo mismo que union()
C = {1, 3, 5}
A.intersection(C) 
A & C # lo mismo que intersection()
A.difference(C)
A - C # lo mismo que difference()
]]></script>
	    <p>
	      Nota que necesariamente aplica que $|A \cup B| \geq
	      \max\{|A|, |B|\}$ igual como $|A \cap B| \leq \min\{|A|,
	      |B|\}$.
	    </p>
	    <p>
	      La notaci&oacute;n $B \subseteq A$ indica que $B$ es
	      un <em>subconjunto</em> de $A$, mientras se escribe $C \nsubseteq
	      A$ para indicar que $C$ contiene algo que no est&eacute; en
	      $A$. Nota que necesariamente $B \subset A \Rightarrow |B| < |A|$.
									  </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
A = {0, 1, 2, 3, 4, 5, 6, 7, 8}
B = set(range(9)) # un conjunto desde 0 hasta 8
A == B
C = {1, 3, 5}
C.issubset(A) # si C es un subconjunto de A
B.issuperset(C) # si C es un subconjunto de B
]]></script>
	    <p>
	      El s&iacute;mbolo $\exists$ refiere a la
	      cuantificaci&oacute;n <strong>existencial</strong> (es decir, algo
	      aplica para por lo menos un elemento), mientras el s&iacute;mbolo
	      $\forall$ refiere a la
	      cuantificaci&oacute;n <strong>universal</strong> (que aplica para
	      todos).
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
A = {1, 3, 5, 7}
all(a % 2 == 1 for a in A) # si todos los elementos de A son impares
any(a % 5 == 0 for a in A) # si por lo menos uno es divisible entre cinco
]]></script>
	    <p>
	      Por lo general se supone que existe un <em>universo</em> de posibles
	      elementos de los cuales los conjuntos est&aacute;n formados. En este caso, 
	      $\bar{A} = \{a \mid a \notin A\}$ refiere al <em>complemento</em> de $A$.
	    </p>
	    <h3>Representaci&oacute;n digital</h3>
	    <p>
	      El <strong>bit</strong> es la unidad b&aacute;sica de
	      informaci&oacute;n digital: tiene dos valores posibles
	      que se interpreta como los valores l&oacute;gicos
	      "verdad" (1) y "falso" (0). La cantidad $b$ de bits
	      requeridos para representar un valor
	      $x\in\mathbb{Z}^{+}$ es el exponente de la m&iacute;nima
	      potencia de dos que es <em>mayor</em> a $x$: $$b =
	      \min_{k \in \mathbb{Z}} \left\{k \mid 2^k > x
		\right\}.$$ Esto quiere decir que cada entero positivo
		es expresable como la <em>suma</em> de ciertas potencias
		de dos de tal manera que cada potencia aparece una vez
		(1) o ninguna (0); las potencias se ordenan de menor (a
		la derecha) a mayor (a la izquierda). 
		A esta representaci&oacute;n de los enteros se llama el sistema <strong>binario</strong>.
		$$\forall i \in \mathbb{Z}, \exists \mathbf{b} \in \{0, 1\}^\ast:  i = \displaystyle \sum_{j = 0}^\infty b_j \times 2^j$$
	    </p>
	    <table>
	      <tr><th>$j$</th><th>$2^j$</th><th>$j$</th><th>$2^j$</th><th>$j$</th><th>$2^j$</th></tr>
	      <tr><td> 0</td><td>    1</td><td>14</td><td>     16,384</td><td>28</td><td>   268,435,456</td></tr>
	      <tr><td> 1</td><td>    2</td><td>15</td><td>     32,768</td><td>29</td><td>   536,870,912</td></tr>
	      <tr><td> 2</td><td>    4</td><td>16</td><td>     65,536</td><td>30</td><td> 1,073,471,824</td></tr>
	      <tr><td> 3</td><td>    8</td><td>17</td><td>    131,072</td><td>31</td><td> 2,147,483,648</td></tr>
	      <tr><td> 4</td><td>   16</td><td>18</td><td>    262,144</td><td>32</td><td> 4,294,967,296</td></tr>
	      <tr><td> 5</td><td>   32</td><td>19</td><td>    524,288</td><td>33</td><td> 8,589,934,592</td></tr>
	      <tr><td> 6</td><td>   64</td><td>20</td><td>  1,048,576</td><td>34</td><td>17,179,869,184</td></tr>
	      <tr><td> 7</td><td>  128</td><td>21</td><td>  2,097,152</td><td>35</td><td>34,359,738,368</td></tr>
	      <tr><td> 8</td><td>  256</td><td>22</td><td>  4,192,304</td><td>36</td><td>68,719,476,736</td></tr>
	      <tr><td> 9</td><td>  512</td><td>23</td><td>  8,388,608</td><td>$\vdots$</td><td>$\vdots$</td></tr>
	      <tr><td>10</td><td>1,024</td><td>24</td><td> 16,777,216</td></tr>
	      <tr><td>11</td><td>2,048</td><td>25</td><td> 33,554,432</td></tr>
	      <tr><td>12</td><td>4,096</td><td>26</td><td> 67,108,864</td></tr>
	      <tr><td>13</td><td>8,192</td><td>27</td><td>134,217,728</td></tr>
	    </table>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
for potencia in range(37):
    print(2**potencia)



]]></script>
	    <p>
	      El <strong>byte</strong> es la unidad b&aacute;sica
	      de <em>capacidad</em> de memoria digital: es una sucesi&oacute;n
	      de ocho bits, por lo cual el n&uacute;mero entero m&aacute;s
	      grande que se puede guardar en un solo byte es $2^8 - 1$ = 255.
	      Un <em>kilobyte</em> es 1,024 bytes, un <em>megabyte</em> es 1,024
	      kilobytes (1,048,576 bytes) y un <em>gigabyte</em> es 1,024
	      megabytes (1,073,741,824 bytes).  Normalmente el prefijo "kilo"
	      implica un mil, pero como mil no es ning&uacute;n potencia de dos,
	      eligieron la potencia m&aacute;s cercana, $2^{10}$ = 1,024, para
	      corresponder a los prefijos.
	    </p>
	    <p>
	      Cualquier entero positivo podr&iacute;a servir
	      como <em>base</em> a una representaci&oacute;n, no
	      solamente el dos. La computaci&oacute;n usa mucho el dos
	      por la facilidad de la representaci&oacute;n binaria con
	      fen&oacute;menos f&iacute;sicos (apagado versus
	      encendido; alto versus bajo).  Dado un entero positivo
	      $k$, su <strong>conjunto residual</strong> consiste en
	      todos los enteros desde cero hasta $k-1$, $$\mathbb{Z}_k
	      = \{0, 1, 2, \ldots, k-2, k-1\},$$ es decir, todos los
	      posibles resultados del residuo cuando se divide a
	      cualquier entero positivo entre $k$.  Por ejemplo,
	      $\mathbb{Z}_2 = \{0, 1\}$.
	    </p>
	    <table>
	      <tr><th>Sistema ternario</th>
		<td>$\forall i \in \mathbb{Z}, \exists \mathbf{b} \in \mathbb{Z}_3^\ast: i = \displaystyle \sum_{j = 0}^\infty b_j \times 3^j$</td></tr>
	      <tr><th rowspan="2">Sistema octal</th>
		<td>$\forall i \in \mathbb{Z}, \exists \mathbf{b} \in \mathbb{Z}_8^\ast: i = \displaystyle \sum_{j = 0}^\infty b_j \times 8^j$</td></tr>
	      <tr><td>Corresponde a grupos de <em>tres</em> bits.</td></tr>
	      <tr><th>Sistema decimal</th>
		<td>$\forall i \in \mathbb{Z}, \exists \mathbf{b} \in \mathbb{Z}_{10}^\ast:  i = \displaystyle \sum_{j = 0}^\infty b_j \times 10^j$</td></tr>
	      <tr><th rowspan="2">Sistema hexadecimal</th>
		<td>$\forall i \in \mathbb{Z}, \exists \mathbf{b} \in \mathbb{Z}_{16}^\ast: i = \displaystyle \sum_{j = 0}^\infty b_j \times 16^j$</td></tr>
	      <tr><td>Corresponde a grupos de <em>cuatro</em> bits; $a$ = 10, $b$ = 11, $\ldots$, $f = 15$.</td></tr>
	      <tr><th>Base arbitraria</th>
		<td>$k \in \mathbb{Z}, k > 1, \forall i \in \mathbb{Z},  \exists \mathbf{b} \in \mathbb{Z}_k^\ast:  i = \displaystyle \sum_{j = 0}^\infty b_j \times k^j$</td></tr>
	    </table>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
x = 250
bin(x) # binario
oct(x) # octal
hex(x) # hexadecimal
]]></script>


	 <p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/index.html#deOtrasBases"><strong>
	       Ejemplos de conversi&oacute;n de distintas bases a la base decimal</strong></a></p>

	 	 <p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/index.html#aOtrasBases"><strong>
		       Ejemplos de conversi&oacute;n de la base decimal a otras bases</strong></a></p>	    

	 
	    
	    <p>
	      Para representar n&uacute;meros reales por computadora,
	      hay que definir hasta que exactitud se guarda los
	      decimales del n&uacute;mero.  <em>Punto flotante</em> es
	      la representaci&oacute;n se adapta al orden de
	      magnitud del valor $x \in \mathbb{R}$ por trasladar la
	      coma decimal hacia la posici&oacute;n de la primera
	      cifra significativa de $x$ mediante un exponente
	      $\gamma$, $x = m \cdot b^\gamma$, donde $m$ se llama
	      la <em>mantisa</em> y contiene los d&iacute;gitos
	      significativos de $x$. El par&aacute;metro $b$ es la
	      <em>base</em> del sistema de representaci&oacute;n, mientras $\gamma
	      \in \mathbb{Z}$ determina el rango de valores posibles (por la
	      cantidad de memoria que tiene reservada). 
	      </p>
	    <p>
	      Hay que tener mucho cuidado con la operaci&oacute;n de parte entera en
	      programaci&oacute;n, como implica p&eacute;rdida de datos. Por
	      ejemplo, considera lo siguiente:
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
a = 0.6 / 0.2
b = int(a)
print(b)
]]></script>
	    <p>
	      Esto suele resultar en <span class="codevar">b</span> asignada al valor 2 y no
	      3, porque por la representaci&oacute;n binaria de punto flotante de
	      0.6 y 0.2, su divisi&oacute;n resulta en 2.9999999999999996.
	    </p>
	    </div>
	    <div class="clase">
	    <h3>L&oacute;gica booleana</h3>
	    <p>
	      La l&oacute;gica es el tema del cap&iacute;tulo 2 de
	      Grimaldi. El momento que necesites ejemplos detallados,
	      checa el libro.
	      </p>
	    <p>
	      
	      Los <strong>valores de verdad</strong> son dos: verdad $\top$ y
	      falso $\bot$, frecuentemente representados como uno y
	      cero, respectivamente (como en el sistema
	      binario). Variables booleanas pueden tomar estos
	      valores. Por ejemplo, comparaciones de
	      n&uacute;meros producen valores de verdad:
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
3 < 5
8 / 2 == 4
7 <= 7
a = (8 > 2)
9 != 6
]]></script>
	    <p>
	      Se tiene un conjunto $X = \{ x_1, x_2, \ldots \}$
		de <em>variables</em> (tambi&eacute;n: llamados
		&aacute;tomos). Cada variable puede tomar el valor
		"verdad" $\top$ o "falso" $\bot$.
		La <em>negaci&oacute;n</em> de una variable $x_i$.
		$\neg x_i = \top$ si $x_i = \bot$, mientras $\neg x_i
		= \bot$ si $x_i = \top$. Es decir, $\neg x_i$ se lee
		"no $x_i$" (en ingl&eacute;s: "not $x_i$").
	      </p>
	    <p>
	      Se forman <em>proposiciones</em> combinando los valores
	      de verdad y/o variables booleanas con conectivos.
	      Expresiones b&aacute;sicas son los <em>literales</em>
	      $x_i$ y $\neg x_i$. Se forman m&aacute;s expresiones
	      utilizando los <em>conectivos</em> $\vee $ ("o" lo que
	      en ingl&eacute;s es un "or"), $\wedge $ ("y" lo que en
	      ingl&eacute;s es un "and") &mdash; tambi&eacute;n $\neg$
	      se considera un conectivo. Si $\phi_1$ y $\phi_2$ son
	      expresiones booleanas, tambi&eacute;n $(\phi_1 \vee
	      \phi_2)$, $(\phi_1 \wedge \phi_2)$ y $\neg \phi_1$ lo
	      son.
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
b = not (9 == 6) # es un "no"
c = a and b # es un "y"
d = a or b # es un "o"
]]></script>
	    <p>
	      Los <strong>operadores l&oacute;gicos</strong> b&aacute;sicos son "no"
	      con "y" o "o". Con la negaci&oacute;n unaria y uno de los dos
	      operadores binarios, se pueden definir el resto.  Los operadores
	      l&oacute;gicos derivados incluyen los siguientes:
	      </p>
	    <ul>
	      <li>$\oplus$ = XOR (o exclusivo),</li>
	      <li>$\rightarrow$ =  implicaci&oacute;n y </li>
	      <li>$\leftrightarrow$ = equivalencia.</li>
	    </ul>
	    <table>
	      <tr><td>$\varphi_1 \oplus \varphi_s$ significa $(\varphi_1 \vee \varphi_2) \wedge \neg (\varphi_1 \wedge \varphi_2)$</td></tr>
	      <tr><td>$\displaystyle\bigvee_{i=1}^n \varphi_i$ significa $\varphi_1 \vee \cdots\vee \varphi_n$</td></tr>
	      <tr><td>$\displaystyle\bigwedge_{i=1}^n \varphi_i$ significa $\varphi_1 \wedge \cdots\wedge \varphi_n$</tr><tr>
	      <tr><td>$\phi_1 \rightarrow \phi_2$ significa $\neg \phi_1 \vee  \phi_2$</td></tr>
	      <tr><td>$\phi_1 \leftrightarrow \phi_2$ significa  $(\neg \phi_1 \vee  \phi_2) \wedge  (\neg \phi_2 \vee  \phi_1)$</td></tr>
	    </table>
	    <p>
	      Uno puede
	      definir <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/boolOper.py">subrutinas
	      propias en Python para XOR, implicaci&oacute;n y
	      equivalencia</a>.
	    </p>
	    <p>
	      Para determinar si una expresi&oacute;n booleana se
	      puede satisfacer con alguna asignaci&oacute;n a sus
	      variables, se procede a evaluar todas las posibles
	      combinaciones de valores a sus variables de forma
	      sistem&aacute;tica en un cuadro. A este cuadro se le
	      dice "tabla de verdad"; abajo est&aacute;n las tablas de
	      verdad de "y", "o" y "xor".
	    </p>
	    <table>
	      <tr><th>$a$</th><th>$b$</th><th>$a \wedge b$</th></tr>
	      <tr><td>$\bot$</td><td>$\bot$</td><td>$\bot$</td></tr>
	      <tr><td>$\bot$</td><td>$\top$</td><td>$\bot$</td></tr>
	      <tr><td>$\top$</td><td>$\bot$</td><td>$\bot$</td></tr>
	      <tr><td>$\top$</td><td>$\top$</td><td>$\top$</td></tr>
	    </table>
	    <br>
	    <table>
	      <tr><th>$a$</th><th>$b$</th><th>$a \vee b$</th></tr>
	      <tr><td>$\bot$</td><td>$\bot$</td><td>$\bot$</td></tr>
	      <tr><td>$\bot$</td><td>$\top$</td><td>$\top$</td></tr>
	      <tr><td>$\top$</td><td>$\bot$</td><td>$\top$</td></tr>
	      <tr><td>$\top$</td><td>$\top$</td><td>$\top$</td></tr>
	    </table>
	    <br>
	    <table>
	      <tr><th>$a$</th><th>$b$</th><th>$a \oplus b$</th></tr>
	      <tr><td>$\bot$</td><td>$\bot$</td><td>$\bot$</td></tr>
	      <tr><td>$\bot$</td><td>$\top$</td><td>$\top$</td></tr>
	      <tr><td>$\top$</td><td>$\bot$</td><td>$\top$</td></tr>
	      <tr><td>$\top$</td><td>$\top$</td><td>$\bot$</td></tr>
	    </table>
	    <p>
	      Si la expresi&oacute;n contiene $n$ variables, su tabla
	      de verdad contiene $2^n$ renglones. Conviene crear
	      columnas auxiliares para subexpresiones cuando la
	      expresi&oacute;n contiene m&uacute;ltiples conectivos.
	    </p>
	    
	    <p>
	      Un posible orden de <em>precedencia</em> de operadores
	      l&oacute;gicos es el siguiente (aunque no viene escrita
	      en piedra m&aacute;s all&aacute; de que la
	      negaci&oacute;n sea la m&aacute;s fuerte &mdash; en
	      electr&oacute;nica es com&uacute;n que $\wedge$ sea
	      m&aacute;s fuerte que $\vee$ y no hay ning&uacute;n
	      acuerdo global sobre la posici&oacute;n del $\oplus$) de
	      la m&aacute;s fuerte al m&aacute;s d&eacute;bil: $\neg$,
	      $\vee $, $\wedge $, $\rightarrow$, $\leftrightarrow$.
	      Por ejemplo $$\neg x_1 \vee x_2 \rightarrow x_3
	      \leftrightarrow \neg x_4 \wedge x_1 \vee x_3$$
	      deber&iacute;a ser interpretada bajo este orden de
	      precedencia como $$((((\neg x_1) \vee x_2) \rightarrow
	      x_3) \leftrightarrow ((\neg x_4) \wedge (x_1 \vee
	      x_3))).$$ Se recomienda siempre utilizar
	      par&eacute;ntesis para evitar confusi&oacute;n, y al no
	      ser posible, especificar de manera expl&iacute;cita la
	      precedencia que no utiliza.
	    </p>
	    <p>
	      <strong>&Aacute;rboles de decisi&oacute;n</strong> son
	      representaciones gr&aacute;ficas de expresiones booleanas donde
	      las variables se representan como hojas de un &aacute;rbol y
	      los operadores l&oacute;gicos reunen ramos (m&aacute;s que la
	      negaci&oacute;n, siendo unaria, es de un s&oacute;lo ramo). Se asignan
	      los valores de verdad a las variables y se propagan a
	      trav&eacute;s de la evaluaci&oacute;n de los operadores hasta alcanzar
	      la ra&iacute;z del &aacute;rbol que contiene el &uacute;ltimo operador por
	      evaluar y as&iacute; produce el valor de la expresi&oacute;n.
	      </p>
	    <img width="400" src="img/aded.png" alt="Ejemplo de un &aacute;rbol de decisi&oacute;n">
	 <p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/logica/arboles.html"><strong>Herramienta
	 interactiva para evaluaci&oacute;n de expresiones booleanas con sus
	 &aacute;rboles de decisi&oacute;n correspondientes</strong></a></p>
	 
	 Un variante de este concepto son los diagramas de decisi&oacute;n
	      binarios (ingl&eacute;s: binary decision diagram, BDD)
	      que representan funciones booleanas de tal forma que
	      cada nivel corresponde a una variable y sus posibles
	      valores (verdad y falso) producen dos ramos. Obviamente
	      diferentes ordenamientos de variables producen
	      diferentes &aacute;rboles.
	    </p>
	    <img width="400" src="img/bdd.png" alt="Ejemplo de BDD">
	    <p><small>Ilustraci&oacute;n modificada del original
	    en <a href="https://upload.wikimedia.org/wikipedia/commons/9/91/BDD.png">https://upload.wikimedia.org/wikipedia/commons/9/91/BDD.png</a>
	    para eliminar color de fondo blanco.</small>


	      
	    <p>
	      Se puede simplificar a un BDD eliminando recursivamente
	      estructuras repetidas hasta que ya no quede ninguna.
	    </p>
	    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/BDD_simple.svg/378px-BDD_simple.svg.png" width="250" alt="BDD simplificado">



	    
	    <p>
<em>Inferencia</em> refiere a derivar expresiones verdaderas a partir
de un conjunto de expresiones que se conocen ser verdaderas. Las
reglas b&aacute;sicas de inferencia incluyen la <em>modus ponens</em>
$$(a \wedge (a \rightarrow b)) \Rightarrow b,$$
<em>modus tollens</em>
$$((a \rightarrow b) \wedge \neg b) \Rightarrow \neg a$$
y el <em>silogismo</em>
$$((a \rightarrow b) \wedge (b \rightarrow c)) \Rightarrow (a \rightarrow c).$$
</p>

	    <p>
	      Denotamos por $X(\phi)$ el conjunto de variables
	      booleanas que aparezcan en una expresi&oacute;n $\phi$.
	      Una <strong>asignaci&oacute;n de valores de
	      verdad</strong> $T: X' \rightarrow \{\top,\bot\}$ se
	      dice <em>adecuada</em> para $\phi$ si $X(\phi) \subseteq
	      X'$ (es decir, cada variable recibe un valor).
	      Escribamos $x_i \in T$ si $T(x_i) = \top$ y $x_i \notin
	      T$ si $T(x_i) = \bot$.
	    </p>
	    <p>
	      Si $T$ <em>satisface</em> a $\phi$, se escribe $T \models \phi$.
	    </p>
	    <ul>
	      <li>Si $\phi \in X'$, $T \models \phi$ si y s&oacute;lo si
		$T(\phi) = \top$.</li>
	      <li>Si $\phi = \neg \phi'$, $T \models \phi$ si y s&oacute;lo si
		$T \not\models \phi'$.</li>
	      <li>Si $\phi = \phi_1\wedge \phi_2$, $T \models \phi$ si y
		s&oacute;lo si $T \models \phi_1$ y $T \models \phi_2$.</li>
	      <li>Si $\phi = \phi_1\vee \phi_2$, $T \models \phi$ si y
		s&oacute;lo si $T \models \phi_1$ o $T \models \phi_2$.</li>
	    </ul>
	    <p>En ingl&eacute;s, la expresi&oacute;n "si y s&oacute;lo si" se suele
	    abreviar como "iff" por "if and only if"; se puede anotar
	    como una equivalencia l&oacute;gica con $\Leftrightarrow$ en vez
	    de escribirlo en letra: $\Phi_a \Leftrightarrow \Phi_b$
	    significa lo mismo que $\Phi_a$ es cierto si y s&oacute;lo si $\Phi_b$ es
	      cierto.
	    </p>
	    <p>Dada una expresi&oacute;n booleana y una asignaci&oacute;n a sus
	    variables, el proceso de determinar s&iacute; o no la expresi&oacute;n
	    es verdadera se conoce como la <em>evaluaci&oacute;n</em> de esa
	    expresi&oacute;n bajo esa asignaci&oacute;n.
	      </P>
	    <p><a target="_blank" href="https://github.com/satuelisa/DiscreteMath/blob/master/examples/boolEval.py"><strong>C&oacute;digo en python3
		  para evaluaci&oacute;n de expresiones booleanas</strong></a></p>
	    <h4>Terminolog&iacute;a relevante sobre expresiones booleanas</h4>
	    <ul>
	      <li>A una expresi&oacute;n booleana $\phi$ se dice <em>satisfactible</em>
		si existe una $T$ adecuada para $\phi$ tal que $T \models \phi$.</li>
	      <LI>A una expresi&oacute;n booleana $\phi$ se
	      dice <em>v&aacute;lida</em> si $\forall T: T \models
	      \phi$, es decir, se evalua como verdadera bajo cualquier asignaci&oacute;n.</LI>
	      <LI>Una expresi&oacute;n v&aacute;lida se le dice
	       <em>tautolog&iacute;a</em> y se escribe simplemente
	      $\models \phi$.
	      </LI>
	      <li>
		$\phi$ es una tautolog&iacute;a si s&oacute;lo si $\neg\phi$
		es <em>no satisfactible</em></li>
	      </ul>
	    <p>
	      Dos expresiones $\phi_1$ and $\phi_2$ son <em>l&oacute;gicamente
		equivalentes</em> si para toda asignaci&oacute;n $T$ que es adecuada
	      para las dos expresiones aplica que $T \models \phi_1$ si y
	      s&oacute;lo si $T \models \phi_2$. La equivalencia l&oacute;gica se
	      denota por $\phi_1 \equiv \phi_2$.
	    </p>
	    <p>
	      La <strong>forma normal conjuntiva</strong> CNF utiliza puramente el
	      conectivo $\wedge $ y literales. La <strong>forma normal
		disyunctiva</strong> DNF utiliza puramente el conectivo $\vee $ y
	      literales. Una conjunci&oacute;n de literales se llama
	      un <em>implicante</em> y una disyunci&oacute;n de literales se llama
	      una <em>cl&aacute;usula</em>. Supongamos que ninguna cl&aacute;usula
	      ni implicante sea repetido en una forma normal, y tampoco se repiten
	      literales dentro de las cl&aacute;usulas o los implicantes.  Las
	      expresiones en forma normal pueden en el peor caso tener un
	      <em>largo exponencial</em> en comparaci&oacute;n con el largo de la
	      expresi&oacute;n original.
	    </p>
	    <p>
	      Transformaciones de expresiones l&oacute;gicas se realizan aplicando
	      reglas de equivalencia:
	    </p>
	    <ul>
	      <li>Reemplazar $\phi_1\leftrightarrow\phi_2$ con
		$(\neg\phi_1\vee \phi_2) \wedge (\neg\phi_1\vee \phi_2)$.</li>
	      <li>Reemplazar $\phi_1\rightarrow\phi_2$ con $\neg\phi_1\vee \phi_2$.</li>
	      <li>Mover los $\neg$ a las variables para formar literales: 
		<ul>
		  <li>$\neg\neg \phi$ se reemplaza con $\phi$,</li>
		  <li>$\neg(\phi_1\vee  \phi_2)$ se reemplaza con $\neg \phi_1\wedge \neg \phi_2$ y</li>
		  <li>$\neg(\phi_1\wedge  \phi_2)$ se reemplaza con $\neg \phi_1\vee \neg \phi_2$.</li>
		</ul>
	      </li>
	    </ul>
	    <p>
	      Transformaciones al CNF se logran moviendo los $\wedge $ afuera de los disyunciones:
	    </p>
	    <ul>
	      <li>$\phi_1\vee (\phi_2\wedge  \phi_3)$ se reemplaza con $(\phi_1\vee  \phi_2)\wedge (\phi_1\vee  \phi_3)$,</li>
	      <li>$(\phi_1\wedge  \phi_2)\vee  \phi_3$ se reemplaza con $(\phi_1\vee  \phi_3)\wedge (\phi_2\vee  \phi_3)$.</li>
	    </ul>
	    <p>Para transformaciones al DNF, se mueven los $\vee $ afuera de los conjunciones:
	    </p>
	    <ul>
	      <li>$\phi_1\wedge (\phi_2\vee  \phi_3)$ se reemplaza con $(\phi_1\wedge  \phi_2)\vee (\phi_1\wedge  \phi_3)$,</li>
	      <li>$(\phi_1\vee  \phi_2)\wedge  \phi_3$ se reemplaza con $(\phi_1\wedge  \phi_3)\vee (\phi_2\wedge  \phi_3)$.</li>
	    </ul>
	    <p>
	      Una <strong>funci&oacute;n booleana</strong> $f$ de $n$-dimensiones
	      es un mapeo de $\{ \top, \bot \}^n$ al conjunto $\{ \top, \bot\}$. La
	      negaci&oacute;n $\neg$ corresponde a una funci&oacute;n unaria
	      $f^{\neg}: \{\top, \bot\} \rightarrow \{\top, \bot\}$, mientras los
	      otros dos conectivos b&aacute;sicos $\vee$ y $\wedge$ (igual como los
	      derivados $\oplus$, $\rightarrow$ y $\leftrightarrow$) definen cada
	      uno una funci&oacute;n binaria $f : \{\top, \bot\}^2 \rightarrow
	      \{\top, \bot\}$. Cada expresi&oacute;n booleana se puede interpretar
	      como una funci&oacute;n booleana con la dimensi&oacute;n $n =
	      |X(\phi)|$. La expresi&oacute;n $\phi$ expresa una funci&oacute;n $f$
	      si cada $n$-eada de valores de verdad $\tau = (t_1,\ldots,t_n)$ aplica
	      que $$ f(\tau)= \left\{ \begin{array}{ll} \top, & \text{ si }
	      T\models\phi, \\ \bot, & \text{ si } T\not\models\phi, \end{array}
	      \right.  $$ donde $T$ es tal que $T(x_i) = t_i$ para todo $i =
	      1,\ldots,n$.
	    </p>
	    <h4>Problema de satisfiabilidad SAT</h4>
	    <p>
	      <em>Entrada</em>: una expresi&oacute;n booleana $\phi$ en CNF.<br>
	      <em>Pregunta</em>: &iquest; es $\phi$ satisfactible?
	    </p>
	    <p>Al SAT se puede resolver utilizando tablas de asignaciones en
	      tiempo $\mathcal{O}(n^2 \cdot 2^n).$ (M&aacute;s adelante veremos
	      qu&eacute; quiere decir esa cosa de $\mathcal{O}$.)
	    </p>
	    <p>
	      <strong>L&oacute;gica proposicional</strong>, llamado
	      "l&oacute;gica de primer orden", es una l&oacute;gica
	      donde se cuantifica a variables individuales y las
	      proposiciones tienen que ver con si existe ($\exists$)
	      una variable para la cual una condici&oacute;n
	      est&eacute;e v&aacute;lida o si para todas ($\forall$)
	      las aplique alguna condici&oacute;n.  Los
	      cuantificadores se discuten en la secci&oacute;n 2.4 de
	      Grimaldi. Nota que $\neg \forall P$ significa "no para
	      todos aplica P" es lo mismo que $\exists \neg P$, es
	      decir, "existe algo para el cual no aplica P".
	    </p>
	    <p>
	      Operaciones con valores de verdad, cuando se expresan en
	      t&eacute;rminos de cero (falso) y uno (verdad), son en
	      realidad <em>&aacute;lgebra booleana</em> (checa el
	      cap&iacute;tulo 15 de Grimaldi por m&aacute;s
	      detalles). Por lo general $\wedge$ es una
	      multiplicaci&oacute;n, $\vee$ es redondear hac&iacute;a arriba
	      el promedio y $\oplus$ es como sumar en m&oacute;dulo dos.
	    </p>

	    <h4>Operaciones l&oacute;gicas con enteros</h4>
	    <p>
	      La <strong>aritm&eacute;tica binaria</strong> refiere a
	      la l&oacute;gica booleana que opera con los bits de uno o dos
	      enteros. Las operaciones t&iacute;picas son
	      <ul>
	      <li>la negaci&oacute;n "no" (~)</li>
	      <li>la conjunci&oacute;n "y" (&)</li>
	      <li>la disyunci&oacute;n "o" (|)</li>
	      <li>la disyunci&oacute;n exclusiva "xor" (^)</li>
</ul>
	      y adem&aacute;s se cuenta con operadores para llevar a cabo
	      <em>desplazamiento</em> izquierdo (<<) y derecho (>>),
	      cuyos nombres refieren a la direcci&oacute;n a la cual se
	      desplazan los bits.
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
a = 1000
b = 7
~a # intercambios los ceros con unos y vice versa
a & b # y binario (ver ejemplo abajo)
a | b # o binario (ver ejemplo abajo)
a ^ b # o-exclusivo binario (ver ejemplo abajo)
a << b # agregar b ceros a la derecha, moviendo bits <- a la IZQUIERDA
a >> b # quitar b bits a la izquierda, moviendo bits -> a la DERECHA 
]]></script>

<p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/logica/bitwise_and.png"><strong>
      Ejemplo de una conjunci&oacute;n por bits</strong></a></p>

<p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/logica/bitwise_or.png"><strong>
      Ejemplo de una disyunci&oacute;n por bits</strong></a></p>

<p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/logica/bitwise_xor.png"><strong>
      Ejemplo de una disyunci&oacute;n exclusiva por bits</strong></a></p>


	   	    
	  </div>
	  <div class="ejercicio">
	    <h3 id="e1">Tarea 1</h3>
	    <p>
	      Pregunta 1: <em>&Aacute;lgebra de conjuntos</em>: El resultado de $A \cup
	      (B \setminus (C \cap D))$ con $A = \{$<span id="d1.A">2,
	      4, 6, 8</span>$\}$, $B = \{$<span id="d1.B">3, 5,
	      7</span>$\}$, $C = \{$<span id="d1.C">1, 2, 3,
	      4</span>$\}$ y $D = \{$<span id="d1.D">4, 5, 6, 7,
	      9</span>$\}$:
	      <input type="text" id="r1.1" size="20" value="">
	    </p>
	    <span id="c1.1"></span>
	    <p>
	      Pregunta 2: <em>Interpretaci&oacute;n de n&uacute;meros binarios</em>: El valor decimal del n&uacute;mero
	      binario <span id="d1.bin">10001111</span>:
	      <input type="text" id="r1.2" size="10" value="">
	    </p>
	    <span id="c1.2"></span>
	    <p>
	      Pregunta 3: <em>Conversi&oacute;n de bases</em>: La representaci&oacute;n en
	      base <span id="d1.base">5</span> del valor
	      decimal <span id="d1.dec">78</span>:
	      <input type="text" id="r1.3" size="10" value="">
	    </p>
	    <span id="c1.3"></span>
	    <p>
	      Pregunta 4: <em>Aritm&eacute;tica binaria</em>: El resultado de 
	      <span class="codevar">(a & (b << c))</span> donde  
              $a$ = <span id="d1.a">1000</span>,
	      $b$ = <span id="d1.b">500</span> y
              $c$ = <span id="d1.c">7</span>: 
             <input type="text" id="r1.4" size="10" value="">
	    </p>
	    <span id="c1.4"></span>
	    <p>
	      Pregunta 5: <em>Evaluaci&oacute;n de expresiones booleanas</em>: El valor <em>binario</em> de la expresi&oacute;n 
	      $(x \vee z) \wedge \neg (\neg y \vee \neg z)$ cuando $x =$
	      <span id="d1.x">1</span>, $y =$ <span id="d1.y">0</span> &amp; 
	      $z =$ <span id="d1.z">1</span>: 
	      <input type="text" id="r1.5" size="10" value="">
	    </p>
	    <span id="c1.5"></span>
	    <div class="calif" id="ce1">
	      <span id="s1"></span>
	      <span id="l1"></span>
	    </div>
	      <h4>Preguntas de verificaci&oacute;n</h4>
	    <p>
	      <em>Discute lo siguiente con los compa&ntilde;eros y con
		la profesora hasta que est&eacute; todo
		claro. Conviene consultar el libro de texto (cap&iacute;tulos
		y secciones indicados en el material de la unidad en
		esta p&aacute;gina) y hasta buscar por videos en la
		web. Cuando ya no cabe duda, procede a la segunda
		unidad tem&aacute;tica.</em>
	    </p>
	    <p>&iquest;Para qu&eacute; sirven los conjuntos? &iquest;Qu&eacute;
	      relaci&oacute;n tienen con consultas en bases de datos?
	      &iquest;Por qu&eacute; no importa en que orden est&aacute;n los
	      elementos? &iquest;Por qu&eacute; no puede entrar un mismo
	      elemento muchas veces en un conjunto? (Pregunta 1)
	    </p>
	    <p>&iquest;Para qu&eacute; sirve la base dos? &iquest;Por qu&eacute; se
	    llama binario?  &iquest;Para qu&eacute; existen otras bases como
	    16 y 20? &iquest;Qu&eacute; relaciones tienen entre ellos las
	    bases 2, 8 y 16? (Preguntas 2 y 3)
	    </p>
	    <p>
	      &iquest;Por qu&eacute; se hace l&oacute;gica con enteros y no
	      solamente con valores de verdad sencillas de un
	      s&oacute;lo bit? &iquest;Qu&eacute; se gana con esto? &iquest;Para
	      qu&eacute; se puede aplicar? (Pregunta 4)
	    </p>
	    <p>
	      &iquest;Qu&eacute; aplicaciones tiene en la ingenier&iacute;a
	      la l&oacute;gica booleana? &iquest;Para qu&eacute; lo necesita
	      un mecatr&oacute;nico? &iquest;Para qu&eacute; lo necesita un
	      administrador de sistemas? &iquest;Para qu&eacute; lo necesita
	      un ingeniero de software? &iquest;Qu&eacute; relaci&oacute;n
	      tiene con circuitos digitales? &iquest;Qu&eacute;
	      relaci&oacute;n tiene con la programaci&oacute;n?
	      (Pregunta 5)
	    </p>
	  </div>
	</div>
	<div class="unidad">
	  <h2 id="comb">Combinatoria</h2>
	  <div class="clase">
	    <p>
	      La combinatoria estudia maneras de seleccionar y ordenar
	      elementos de conjuntos. Una <em>permutaci&oacute;n</em>
	      es un ordenamiento de los elementos de un conjunto. Si
	      $|A| = k$, existen $k! = 1 \times 2 \times \ldots \times
	      (k - 1) \times k$ permutaciones de los elementos de
	      $A$. Las permutaciones son el tema de la secci&oacute;n
	      1.2 de Grimaldi.
</p>
<p>
La funci&oacute;n $k!$ es el factorial: $$n! = \prod_{k=1}^n k$$ para
	      enteros positivos (factorial de cero se puede definir
	      por cuestiones de compatibilidad como, aunque en algunos
	      textos prefieren el cero, seg&uacute;n para qu&eacute;
	      prop&oacute;sito se define). La funci&oacute;n factorial
	      es el tema de la secci&oacute;n 4.4 de Concrete
	      Mathematics.
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from math import factorial
factorial(5) # subrutina existente
# una forma eficiente de calcular una secuencia:
f = 1
for i in range(1, 20): 
    f *= i
    print('{:d}! = {:d}'.format(i, f))



]]></script>

	    <p>
	      Por ejemplo, si $A = \{a, b, c\}$, se tiene $3! = 6$ posibles
	      permutaciones: $abc, acb, bac, bca, cab, cba$. Esto es
	      porque hay $k$ maneras de seleccionar el primer
	      elemento, $k-1$ opciones para el segundo,
	      etc&eacute;tera, hasta que en el &uacute;ltimo elemento
	      ya no queda m&aacute;s que una sola opci&oacute;n.
	    </p>
	    <p>
	      Para todo este tipo de cosa, en Python conviene utilizar
	      la
	      librer&iacute;a <a target="_blank" href="https://docs.python.org/dev/library/itertools.html">itertools</a>.
	    </p>
	    <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from itertools import permutations 
p = list(permutations(['a','b','c','d']))
len(p)
]]></script>

<p>
Se puede pensar en una permutaci&oacute;n como un mapeo de posiciones
originales a las nuevas posiciones.  Una <em>composici&oacute;n</em>
de permutaciones es la aplicaci&oacute;n de una despu&eacute;s de
otra. Estos mapeos se pueden representar con matrices de adyacencia
que indiquen cu&aacute;l elemento va en lugar de cu&aacute;l y la
multiplicaci&oacute;n de estas matrices da el efecto de
composici&oacute;n de las permutaciones. Permutaciones de $n$
elementos y su composici&oacute;n forman un grupo.
</p>

	    <p>
	      Para seleccionar desde un conjunto $A$, $|A| = n$, un
	      subconjunto de cardinalidad $0 \leq k \leq n$, hay
	      $\binom{n}{k} = \displaystyle\frac{n!}{k!(n - k)!}$
	      maneras de hacer esto: el primer elemento se selecciona
	      libremente entre los $n$ elementos, mientras el segundo
	      tiene $n - 1$ opciones, etc., pero al hacer esto hay
	      $k!$ formas de llegar a seleccionar el mismo subconjunto
	      pero en un orden distinto.</p>
	    <p>
A este tipo de conjuntos seleccionados se les
llaman <em>combinaciones</em> y se discuten en la secci&oacute;n 1.3
de Grimaldi. Al valor $\binom{n}{k}$ se llama el <em>coeficiente
binomial</em>.  Las coeficientes binomiales son el tema del
cap&iacute;tulo 5 de Concrete Mathematics.
</p>
	    <p>
	      Aunque varias librer&iacute;as ya la contienen, conviene saber
	      definir
	      una <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/binom.py">subrutina
	      (ligeramente optimizada) para calcular el coeficiente
	      binomial</a> en Python.</p>
	      
<p>
Para crear combinaciones de elementos desde un conjunto, pero
permitiendo <em>repeticiones</em>, la f&oacute;rmula cambia ya que el
elemento seleccionado sigue siendo un candidato para selecciones futuras:
$\binom{n + k - 1}{k}$.
</p>
	    <p>
	      El <em>conjunto potencia</em> $2^A$ est&aacute; formado por todos los posibles
	      subconjuntos de $A$ (incluyendo al $A$ mismo y a $\emptyset$).
	      Aplica que $|2^A| = 2^{|A|}$.
	    </p>

<p><a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/subsets.py">Ejemplos
con subconjuntos en Python</a></p>
	    </div>
<div class="clase">
	    <h3>Demostraciones</h3>
	    <p>
	      En las matem&aacute;ticas, a los hechos universales se
	      les dice <em>axiomas</em>.
	      Una <em>definici&oacute;n</em> es una manera de fijar el
	      sentido de alg&uacute;n formalismo, notaci&oacute;n o
	      terminolog&iacute;a. La meta de las demostraciones es
	      derivar de los axiomas y las definiciones,
	      algunos <strong>teoremas</strong>.  (Teoremas auxiliares
	      que se obtienen como resultados intermedios al buscar
	      comprobar alguna cosa mayor se llaman <em>lemas</em>.)
	      La demostraci&oacute;n en s&iacute; es una cadena de
	      pasos que establecen que un teorema sea verdad.
	    </p>
	    <p>
	      Una t&eacute;cnica b&aacute;sica de demostraci&oacute;n es la
	      <em>inducci&oacute;n</em>, donde primero se establece
	      que una <em>condici&oacute;n inicial</em> $c_1$ es
	      v&aacute;lida y verdadera (el paso base). Luego,
	      el <strong>paso inductivo</strong> consiste en comprobar
	      que si $c_k$ es v&aacute;lida y verdadera,
	      tambi&eacute;n $c_{k+1}$ lo debe ser.  La
	      inducci&oacute;n matem&aacute;tica es el tema del
	      cap&iacute;tulo 4 de Grimaldi.
	    </p>
	    <p>
	      Por ejemplo, para resolver a $$T(n) \leq \left\{
	      \begin{array}{ll} c, & \text{ si } n = 1 \\
	      g\Big(T(n/2), n\Big), & \text{ si } n > 1
	      \end{array}\right.$$
							       
              primero <em>adivinamos</em> que la soluci&oacute;n sea, en forma
              general, $T(n) \leq f(a_1, \ldots, a_j, n)$, donde $a_1, \ldots, a_j$
	      son par&aacute;metros de la funci&oacute;n $f$. Para mostrar que para
              algunos valores de los par&aacute;metros $a_1, \ldots, a_j$ aplica
              $\forall n$ que la soluci&oacute;n sea la adivinada, tenemos que
              demostrar que $c \leq f(a_1, \ldots, a_j, 1) $ y tambi&eacute;n que
              si $n > 1$,
              $$g\left(f\left(a_1, \ldots, a_j, \frac{n}{2}\right), n\right) \leq
              f(a_1, \ldots, a_j, n).$$
            </p>
	    <p> 
	      Aplica que $T(k)
	      \leq f(a_1, \ldots, a_j, k)$ para $1 \leq k < n$ por inducci&oacute;n,
              obteniendo $$T(n) \leq g\left(T\left(\textstyle\frac{n}{2} \right), n\right) \leq
              g\left(f\left(a_1, \ldots, a_j, \textstyle\frac{n}{2}\right), n\right) \leq
              f(a_1, \ldots, a_j, n)$$ si $n > 1$.
	    </p>
	    <p>
Ecuaciones de recurrencia como &eacute;sta y su soluci&oacute;n son el
tema de la secci&oacute;n 7.3 de Concrete Mathematics y del cap&iacute;tulo 10 de Grimaldi.

</p>
</div>
<div class="clase">
<h3>Principios y teoremas &uacute;tiles</h3>
<p>
El <strong>principio de palomar</strong> (ve&aacute;se la secci&oacute;n 5.5 de
Grimaldi) establece que si $m$ palomas est&eacute;n ocupando un total de $n$
nidos y $m > n$, entonces por lo menos un nido contiene dos o m&aacute;s
palomas. (Yo s&eacute;, suena a sentido com&uacute;n.)
</p>
<p>
El <strong>principio de inclusi&oacute;n-exclusi&oacute;n</strong> (tema del
cap&iacute;tulo 8 de Grimaldi) es un poco m&aacute;s complejo, pero tampoco es
posible de entender: dado un conjunto $C$ de cardinalidad $n$ y un
total de $t$ condiciones $c_i$, el n&uacute;mero de elementos en $C$ que no
satisfacen <em>ninguna</em> condici&oacute;n es
$$
\bar{n} = n
- \sum_{1 \leq i \leq t} n_{c_i}
+ \sum_{1 \leq i < j \leq t} n_{c_i c_j}
- \sum_{1 \leq i < j < k \leq t} n_{c_i c_j c_k}
\ldots
+ (-1)^t n_{c_1 c_2 \ldots c_t}
$$
donde $n_S$ es el n&uacute;mero de elementos que satisfacen todas las condiciones incluidos en $S$.
Nota los signos alternantes.
</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Inclusion-exclusion.svg/440px-Inclusion-exclusion.svg.png" width=300 alt="Un diagrama de Venn para ilustrar el principio I-E">
<p>El <strong>teorema de Burnside</strong> (que mucha gente argumenta
no ser de Burnside, pero as&iacute; se conoce) sirve para problemas de conteo
de configuraciones posibles. Se explica en t&eacute;rminos de ejemplos paso a
paso en la secci&oacute;n 16.9 de Grimaldi. Sea $C$ un conjunto de
configuraciones sobre las cuales se opera con un grupo finito de
permutaciones $\mathbb{G}$; habr&aacute;
$$\frac{1}{|\mathbb{G}|} \sum_{\pi \in \mathbb{G}} \psi(\pi)$$
<em>clases de equivalencia</em> a las cuales $C$ se divide por ser
actuado con $\mathbb{G}$, donde $\psi(\pi)$ es la cantidad de
configuraciones en $C$ que son fijas bajo la permutaci&oacute;n $\pi$.
</p>
<p>
Esto es un caso especial del <strong>m&eacute;todo de
enumeraci&oacute;n de Polya</strong> (tratado en la secci&oacute;n
16.11 de Grimaldi) que se expresa en t&eacute;rminos de polinomios que
representan posibles patrones. Tambi&eacute;n el cap&iacute;tulo 17 de
Grimaldi sigue en este tipo de temas. Para personas que contemplan un
posgrado como una opci&oacute;n futura, se recomienda estudiar estos
cap&iacute;tulos tambi&eacute;n. Para inges comunes y corrientes no es
tan cr&iacute;tico saber manipular funciones generadoras y anillos de
polinomios, pero por ejemplo en mi campo de estudio son bastante
relevantes.
</p>
</div>
<div class="clase">
  <h3>Sucesiones, secuencias y series</h3>
  <p>
    La <strong>sucesi&oacute;n de Fibonacci</strong>:
    $$\mathcal{F}_k = \left \{ \begin{array}{ll} 0, &\text{
    si } k = 0 \\ 1, &\text{ si } k = 1 \\ \mathcal{F}_{k -
    1} + \mathcal{F}_{k - 2}, &\text{ para } k > 1.
		   \end{array} \right.$$ 

		   &Eacute;sta es una definici&oacute;n <em>recursiva</em>: algo se
		   define en t&eacute;rminos de si mismo. Para
		   m&aacute;s informaci&oacute;n sobre definiciones
		   recursivas, checa la secci&oacute;n 4.2 de
		   Grimaldi.
		   </p>
<p>
	      A los elementos de la sucesi&oacute;n $\mathcal{F}$ se
	      les dice los los n&uacute;meros Fibonacci; son el tema
	      de la secci&oacute;n 6.6 de Concrete Mathematics.  Para
	      la tarea 1, se recomienda
	      usar <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/fibo.py">una
	      subrutina en Python para calcularla</a>.
           </p>
           <p>
	     A los n&uacute;meros de Fibonacci aplica que $\mathcal{F}(a) >
	     \frac{\phi^a}{\sqrt{5}} - 1$ donde $\phi = \frac{1 + \sqrt{5}}{2}$ es
	     la <em>tasa dorada</em> $\approx 1.618$.
	   </p>
	   <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from math import sqrt # subrutina para la ra&iacute;z cuadrada
(1 + sqrt(5)) / 2 # valor de la tasa dorada
]]></script>
	   
           <p>
	     En Python, <span class="codevar">range(n)</span> va desde cero hasta $n -
	     1$. Nota que <span class="codevar">listado[-1]</span> accede al &uacute;ltimo
	     elemento de una secuencia y <span class="codevar">listado[-2]</span> al
	     pen&uacute;ltimo.
	   </p>
           <p>
	     Dada una secuencia, es com&uacute;n querer realizar
	     operaciones con ella, como por ejemplo sumas o productos
	     totales o parciales de sus elementos. Se escribe $\sum_{i
	     = a}^b$ para la <strong>suma</strong> donde
	     un <em>&iacute;ndice</em> $i$ toma valores enteros desde
	     $a$ hasta $b$ en pasos de uno, mientras para la suma
	     parcial hasta el $n$&eacute;simo elemento se escribe $$S
	     = x_1 + x_2 + x_3 + \ldots + x_n = \displaystyle\sum_{i =
	     1}^n x_i.$$ Para el producto (multiplicaci&oacute;n), la
	     notaci&oacute;n es $$P = x_1 \cdot x_2 \cdot x_3 \cdot
	     \ldots \cdot x_n = \displaystyle\prod_{i = 1}^n x_i.$$
	   </p>
<p>
Sumas son el tema del cap&iacute;tulo 2 de Concrete Mathematics.
Les aplica la <em>ley de distribuci&oacute;n</em> 
$$\sum_{k \in K} c \times a_k = c \sum_{k \in K} a_k$$
y la <em>ley de asociaci&oacute;n</em>
$$\sum_{k \in K} (a_k  + b_k)= \sum_{k \in K} a_k  + \sum_{k \in K} b_k.$$
</p>
<p>
Una suma infinita es una suma sobre una secuencia infinita o un
conjunto infinito de elementos. Si el valor de una sumatoria es
finita, se dice que esa suma <em>converge</em> (si no convegre,
diverge). Recuerda que sumas son efectivamente "integrales discretas".
</p>
<p>
  La diferencia entre conjuntos y secuencias es que una secuencia
  tiene un orden mientras un conjunto no lo tiene. Por ende, en Python
  <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/listVersusSet.py">las
  secuencias no son lo mismo que conjuntos</a>, aunque tambi&eacute;n
  de puede sumar y multiplicar sobre conjuntos. En secuencias se puede
  tener elementos repetidos, mientras en conjuntos esto no sucede.
  
</p>
<p>
Dada dos secuencias $F = f_0, f_1, f_2, \ldots$ y $G = g_0 g_1 g_2
\ldots$,
su <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/convolution.py">convoluci&oacute;n</a>
(ver la secci&oacute;n 7.5 de Concrete Mathematics) es una secuencia
$f_0 g_0, f_0 g_1 + g_0 f_1, \ldots$ donde los elementos valen
$$\sum_k f_k g_{n - k}.$$ Nota que no importa cu&aacute;l es $f$ y
cu&aacute;l es $g$ ya que su intercambio no afecta el resultado.
<p>
</p>Para entender qu&eacute; sucede, intenta imaginar las secuencias
como cintas. Voltea la cinta de $g$ y ponla encima de la cinta de $f$
as&iacute; que los elementos cero est&eacute;n uno encima de otro; el
primer elemento viene su multiplicaci&oacute;n. Ahora, desliza la
cinta de $g$ una posici&oacute;n para que coincidan dos
elementos. Multiplica juntos los que est&eacute;n uno encima de otro y
suma sobre las multiplicaciones. Luego que coindican tres elementos,
etc.
</p>
<p>
Tambi&eacute;n existen versiones donde se toman en cuenta los
elementos que no coinciden con otros; son muy importantes en el
procesamiento de se&ntilde;ales y su versi&oacute;n en dos dimensiones
(con matr&iacute;ces en vez de vectores) se necesita en la
visi&oacute;n computacional (es decir, procesamento de
im&aacute;genes).
</p>
<p>
Una secuencia finita con un orden interesante es
el <strong>c&oacute;digo Gray</strong> que consiste en todas las
cadenas binarias de $b$ bits, ordenadas de tal forma que cada cadena
difiere del anterior en un solo bit (esto aplica tambi&eacute;n con la
primera y la &uacute;ltima cadema). Se puede definir de manera recursiva,
comenzando con un c&oacute;digo vacio (la cadena vac&iacute;a se denota por
$\epsilon$): toma el c&oacute;digo existente, s&aacute;cale una copia; invierte el
orden de esta copia y p&eacute;ga las dos copias juntos; luego, agrega un
cero al inicio de la primera mitad y un uno al inicio de la segunda
mitad. &Eacute;ste es el c&oacute;digo de largo uno, $\ell = 1$. Repite para obtener
un c&oacute;digo de $\ell = 2$, etc.
</p>
<table>
  <tr>
    <th>$\ell = 0$</th>
    <th>$\ell = 1$</th>
    <th>$\ell = 2$</th>
    <th>$\ell = 3$</th>
  </tr>
  <tr><td>$\epsilon$</td><td>0</td><td>00</td><td>000</td></tr>
  <tr><td>          </td><td>1</td><td>01</td><td>001</td></tr>
  <tr><td>          </td><td> </td><td>11</td><td>011</td></tr>
  <tr><td>          </td><td> </td><td>10</td><td>010</td></tr>
  <tr><td>          </td><td> </td><td>  </td><td>110</td></tr>
  <tr><td>          </td><td> </td><td>  </td><td>111</td></tr>
  <tr><td>          </td><td> </td><td>  </td><td>101</td></tr>
  <tr><td>          </td><td> </td><td>  </td><td>100</td></tr>          
</table>

<p>
  Preguntas de mucha importancia pr&aacute;ctica con secuencias incluyen
  <ul>
    <li>Conociendo el valor del elemento, &iquest;cu&aacute;l es su posici&oacute;n en la secuencia? (<em>rank</em>)?</li>
    <li>Conociendo la posici&oacute;n, &iquest;cu&aacute;nto vale el elemento? (<em>unrank</em>)?</li>
  </ul>
  Si ambas estas preguntas tienen una respuesta que es eficiente de
  calcular, ya no ser&aacute; necesario generar la secuencia completa,
  ya que se pueden generar elementos seg&uacute;n necesidad, igual
  como obtener el elemento anterior o posterior de manera eficiente.
  En el <a target="_blank"
  href="https://github.com/satuelisa/DiscreteMath/blob/master/examples">repositorio
  de ejemplos</a> hay implementaciones de estas
  operaciones <a target="_blank"
  href="https://github.com/satuelisa/DiscreteMath/blob/master/examples/gray.py">en
  Python y <a target="_blank"
  href="https://github.com/satuelisa/DiscreteMath/blob/master/examples//gray.c">en
  ANSI C</a> para los c&oacute;digos Gray.
</p>


	   <h4>Aritm&eacute;ticas</h4>
	   <p>
	     <em>Serie</em>: $x_{i + 1} - x_i = d$, donde $d$ es constante:
	     $S_n = \displaystyle\sum_{i = 0}^{n-1} (x_1 + i\cdot d) = 
	     \displaystyle\frac{n(x_1 + x_n)}{2}$.
	   </p>
	   <p><em>Progresi&oacute;n</em>:
	     $\sum_{k = 0}^n (a + bk) = (a + bk/2)(n + 1)$.
	   </p>
	   <p><a href="">Ejemplo en Python</a></p>
	     
	   <h4>Geom&eacute;tricas</h4>
           <p>
	     <em>Serie</em>:
	     $x_{i+1} = x_i \cdot d$: $S = \displaystyle\sum_{i = 0}^{\infty} d^i x_i =
	     \displaystyle\frac{x_1}{1 - d}$ y 
	     $S_n = \displaystyle\sum_{i = 0}^n d^i x_i =
	     \displaystyle\frac{x_1(1 - d^{n+1})}{1 - d}$.
	   </p>
	   <p><a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/arithmeticSeries.py">Ejemplo
	       en Python</a></p>
<p>
<em>Progresi&oacute;n</em>: $\sum_{k = 0}^n a \times x^k = \frac{a -
ax^{n+1}}{1 - x}$.
</p>
<p><a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/geometricSeries.py">Ejemplo en Python</a></p>
</div>
<div class="clase">
	   <h3>Relaciones, mapeos y funciones</h3>
	   <p>
	     Este tema se trata en el cap&iacute;tulo 5 de Grimaldi y
	     nuevamente en el cap&iacute;tulo 7. Cualquier cosa que no
	     entiendes viendo esta p&aacute;gina tendr&aacute;s que
	     consultar en el libro. Hay muchos ejemplos.
	   </p>

	   <p>
<strong>Relaci&oacute;n</strong> $\mathcal{R}$
</p>
	   <ul>
	     <li>$A \times B = \{(a, b) \mid a \in A, b \in B\}$.</li>
	     <li>$\mathcal{R} \subseteq A \times B$.</li>
	     <li>$(a, b) \in \mathcal{R}$ o alternativamente $a \mathcal{R} b$.</li>
	     <li>Se pueden representar con una matriz de adyacencia: $a_{ij} = 1$ si $(a_i, a_j) \in \mathcal{R}$ mientras
	       $a_{ij} = 0$ si $(a_i, a_j) \notin \mathcal{R}$.</li>
	     <li>Transitiva:  $\forall a, b, c \in A$ tales que $a \mathcal{R} b$ y $b \mathcal{R} c$, $a \mathcal{R} c$.</li>
	     <li>Reflexiva: $\forall a \in A$, $a \mathcal{R} a$.</li>
	     <li>Sim&eacute;trica: $(a_i, a_j) \in \mathcal{R} \Leftrightarrow (a_j, a_i) \in \mathcal{R}$.</li>
	   </ul>
	   <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
R = {(2, 4), (5, 10), (3, 6), (4, 7)}
(3, 6) in R
[b for (a, b) in R if a < 5]
[(a, b) for (a, b) in R if 2*a == b]
]]></script>
<p>
	   <strong>Mapeo</strong> $g$</p>
	   <ul>
	     <li>$g: A \rightarrow B$, $g(a) = b$ para significar que $(a, b) \in
	       \mathcal{R}_g$.</li>
	     <li>$A$ es el <em>dominio</em> y $B$ es el <em>rango</em>.</li>
	     <li>Los $b_i \in B$ para las cuales aplica $(a, b_i) \in \mathcal{R}_g$ forman
	       la <em>imagen</em> de $a$ en $B$.</li>
	     <li>Los elementos de $A$ que corresponden a un $b \in B$ as&iacute;
	       que $(a, b) \in \mathcal{R}_g$ son la <em>imagen inversa</em> de $b$,
	       $g^{-1}(b)$.</li>
	     <li>Epiyectivo: $\forall b \in B \exists a \in A \text{ tal que } g(a) = b$.</li>
	     <li>Inyectivo: $\forall a_1, a_2 \in A$ tales que 
	       $g(a_1) = g(a_2) \Rightarrow a_1 = a_2$.</li>
	     <li>Biyectivo: inyectivo y epiyectivo.</li>
	     <li><a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/mapping.py">Ejemplo en Python</a></li>
	   </ul>
         <p>
	   Una <strong>funci&oacute;n</strong> $f: A \rightarrow B$ es un
	   mapeo que asigna a cada elemento de $A$ un &uacute;nico elemento de
	   $B$. Por ejemplo,
	 </p>
	 <ul>
	   <li>$|x| = \left \{ \begin{array}{rl} x, & \text{ si } x \geq 0 \\ -x, & \text{ si } x < 0. \end{array} \right .$</li>
												    
           <li>$\exp(x) = e^x = \displaystyle\sum_{i = 0}^\infty \frac{x^i}{i!} = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \ldots$.</li>
	 </ul>	
<p>
Python tiene una
librer&iacute;a <a target="_blank" href="https://docs.python.org/dev/library/math.html">math</a>
de funciones comunes.
</p>
<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
abs(-5)
from math import exp
exp(1.0)
]]></script>
         <p>
	   $f(x) = \exp(x)$ es la funci&oacute;n <em>exponencial</em>,
	   que tambi&eacute;n se define como un l&iacute;mite $$e^x =
	   \displaystyle\lim_{n \rightarrow \infty} \left ( 1 +
	   \frac{x}{n}\right )^n;$$ su derivada es la misma $D(e^x) =
	   e^x$. Adem&aacute;s tiene las mismas propiedades que
	   cualquier exponenciaci&oacute;n a base $b$; simplemente en
	   este caso la base $b = e \approx 2,718281828$, lo que es
	   la <em>constante de Napier</em>.
	 </p>
	 <img width="500" src="img/exponencial.png">
	 <ul>
	   <li>$b^0 = 1$.</li>
	   <li>$b^1 = b$.</li>
	   <li>$b^{a + c} = b^a b^c$.</li>
	   <li>$b^{ac} = (b^a)^c$.</li>
	   <li>$b^{-a} = \left(\frac{1}{b}\right)^a = \frac{1}{b^a}$.</li>
	 </ul>
         <p>
	   Su funci&oacute;n <em>inversa</em> es el <strong>logaritmo</strong>:
         </p>
	 <img width="500" src="img/logaritmo.png">
	 <ul>
	   <li>La definici&oacute;n es $b^{\log_b x} = x$ donde $x >
	   0$.</li>
	   <li>Si $\log_b x = y$, $b^y = x$ por
	   definici&oacute;n.</li>
	   <li>Se define que $\log_b 1 = 0$.</li>
	   <li>Cambios de base: $\log_{b'}(x) =
	   \displaystyle\frac{\log_b(x)}{\log_b(b')}$.</li>
	   <li>Logaritmo es una funci&oacute;n inyectiva: $\log_b x =
	   \log_b y \Longrightarrow x = y$.</li>
	   <li>Tambi&eacute;n es creciente: $x > y \Longrightarrow
	   \log_b x > \log_b y$.</li>
           <li>Aplica para la multiplicaci&oacute;n que $\log_b (x
           \cdot y) = \log_b x + \log_b y$.</li>
           <li>Divisi&oacute;n es un caso especial de la
           multiplicaci&oacute;n: $\log_b \left(\frac{x}{y}\right) =
           \log_b x - \log_b y$.</li>
           <li>Potencia tambi&eacute;n es simplemente
           multiplicaci&oacute;n repetida: $\log_b x^c = c \log_b
           x$.</li>
           <li>Factorial tambi&eacute;n es una multiplicaci&oacute;n
           repetida: $\log_b(n!) = \displaystyle\sum_{i = 1}^n \log_b
           i$.</li>
           <li>Logaritmo en el exponente permite un cambio de
           variables: $x^{\log_b y} = y^{\log_b x}$.</li>
           <li>El logaritmo <em>natural</em> usa la base $e$: $\ln(x)
           = \log_e(x).$</li>
         </ul>	
         <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from math import log, exp
log(10)
2.302585092994046
log(100, 10)
log(16, 2)
log(exp(1.0))
log(1000, 10) == log(1000)/log(10)
log(8, 2) == log(8) / log(2)
]]></script>
	 <p><a target="_blank" href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/funciones/log.png"><strong>Ejemplos de logaritmos para practicar calcularlos en la cabeza</strong></a></p>
	 <h4>Redondeo de decimal a entero</h4>
         <p>
	   Funciones de redondeo son el tema del cap&iacute;tulo 3 de
	   Concrete Mathematics.
	   </p>
<p>
	   <strong>Piso</strong>: $\lfloor x \rfloor = \max_{y \in \mathbb{Z}}
	   \{y \mid x \geq y\}$. Por definici&oacute;n, $\forall x \in
	   \mathbb{R}$, $\lfloor x \rfloor \leq x < \lfloor x + 1 \rfloor$, $x - 1 <
           \lfloor x \rfloor \leq x$ y $\forall k \in \mathbb{Z}$ y $x \in
           \mathbb{R}$ aplica $\lfloor k + x \rfloor = k+ \lfloor x \rfloor$.
        </p>	 <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from math import floor, pi
floor(pi)
]]></script>
         <p>
	   <strong>Techo</strong>: $\lceil x \rceil = \min_{y \in \mathbb{Z}} \{y \mid x \leq y\}.$ Aplica por
	   definici&oacute;n que $x \leq \lceil x \rceil < x + 1$.
         </p>
	 <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from math import ceil, pi
ceil(pi)
]]></script>
         <p>
	   Consideremos  el siguiente c&oacute;digo:
	 </p>
	 <script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
a = 3.76 # sin probar
b = int(a) 
print(a, b) 
]]></script>
        <p>
	  donde la regla de asignar un valor a <span class="codevar">b</span> es la
	  funci&oacute;n de <strong>parte entera</strong>, $[x]$.  Denote el
	  valor de la variable <span class="codevar">a</span> por $a$. Si $a \geq 0$, se
	  asigna a <span class="codevar">b</span> el valor $\lfloor a \rfloor$, y cuando
	  $a < 0$, se asigna a
	       <span class="codevar">b</span> el valor $\lceil a \rceil$. El redondeo
	       t&iacute;pico "de mitad para arriba" de $x \in \mathbb{R}$ al entero
	       m&aacute;s pr&oacute;ximo es equivalente a $[x + 0.5]$.
	</p>
	<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from math import pi
round(pi)
round(3.5000000001) != round(3.4999999999999999)
]]></script>
       </div>

<div class="clase">
<h3>&Aacute;lgebra abstracta</h3>
<p>
La teor&iacute;a de n&uacute;meros y la &aacute;lgebra abstracta en
general son importantes para la criptograf&iacute;a que es un campo de
la seguridad inform&aacute;tica.
Para m&aacute;s sobre &aacute;lgebra abstracta, v&eacute;ase el cap&iacute;tulos 14 y 15 de
Grimaldi. Adem&aacute;s de criptograf&iacute;a, es necesario en la codificaci&oacute;n de
la informaci&oacute;n (compresi&oacute;n, detecci&oacute;n de errores, etc.).

</p>
<h4>Divisibilidad</h4>
<p>
Un entero que no tiene divisores aparte de si mismo y el uno es
un <em>n&uacute;mero primo</em>. 
Los n&uacute;meros primos se tratan en la secci&oacute;n 4.3 de Grimaldi.
</p>
<p>
Para checar si un n&uacute;mero dado es primo o no, se puede intentar
las divisiones y ver si alguna da un residuo cero. Pens&aacute;ndolo
bien, es est&uacute;pido dividir entre 4 y 6 y 8 si ya se sabe que la
divisi&oacute;n entre dos no fue exacta, por lo cual conviene manejar
los n&uacute;meros pares como un caso especial para hacer menos
intentos de divisi&oacute;n y as&iacute; ahorrale esfuerzo a la
computadora, pero se puede ahorrar a&uacute;n m&aacute;s. Supongamos
que $n$ no sea primo, por lo cual tendr&aacute; que tener por lo menos
dos divisores $n = a \times b$. Para saber que $n$ no es primo, basta
con encontrar el menor de los divisores. &iquest;Qu&eacute; tan grande
puede ser el menor de ellos? Cuando $a$ crece, $b$ disminuye ya que $n
= ab$. Entonces el menor es a su m&aacute;s grande cuando $a \approx
b$, lo que significa que si $a = b$ y $n = ab = a^2$, tenemos que $a =
\sqrt(n)$, por lo cual basta con probar divisores hasta alcanzar la
ra&iacute;z de
$n$. <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/prime.py">Las
tres versiones en Python.</a> Para m&aacute;s detalle sobre
n&uacute;meros primos, checa las secciones 4.2 &amp; 4.3 de Concrete
Mathematics
</p>
<p>
Se dice que dos enteros son <strong>relativamente primos</strong> si
no tienen divisores en com&uacute;n aparte del uno, es decir, su
<em>mayor divisor com&uacute;n</em> (GCD por sus siglas en
ingl&eacute;s) es uno. Nota que $c = $GCD$(a, b) \Rightarrow \exists
x, y \in \mathbb{Z}$ as&iacute; que $c = (x \times a) + (y \times b)$.
La GDC es el tema de la secci&oacute;n 4.1 de Concrete
Mathematics. Nota que dos n&uacute;meros primos siempre son
relativamente primos entre ellos y un n&uacute;mero primo es
relativamente primo con cualquier otro entero. Se escribe $a \perp b$
para indicar que $a$ y $b$ son relativamente primos. Los primos
relativos se discuten en la secci&oacute;n 4.5 de Concrete
Mathematics.
</p>
<p>
Aplica que el GCD entre $a$ y $b$ es el mismo que el CGD entre $b$ y
$a$ mod $b$, lo que nos permite definir
un <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/gcd.py">algoritmo
recursivo</a> para calcularlo: el <em><a target="_blank"
href="https://codility.com/media/train/10-Gcd.pdf">algoritmo
Euclideano</a></em> para el GCD, que es el tema de la secci&oacute;n
4.4 de Grimaldi.
</p>
<p><a target="_blank"
href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/funciones/gcd.png"><strong>Ejemplos
de GCD para practicar calcularlos a mano</strong></a></p>
<p><a target="_blank" href="https://github.com/satuelisa/DiscreteMath/blob/master/examples/gcd.py"><strong>Variantes para calcular GCD en python3</strong></a></p>
<h4>Grupos</h4>
<p>
Sea $G$ un conjunto y $\circ$ un operador binario. $\mathbb{G} = (G, \circ)$ es
un <em>grupo</em> si aplican las siguientes cuatro propiedades:
</p>
<ol>
<li>Clausura: $\forall g, h \in G, i = g \circ h \in G$.</li>
<li>Asociatividad: $\forall g, h, i \in G: (g \circ h) \circ i = g \circ (h \circ i)$.</li>
<li>Identidad: $\exists e \in G$ tal que $\forall g \in G: e \circ g = g \circ e = g$.</li>
<li>Inversi&oacute;n: $\forall g \in G \exists h \in G$ tal que $h \circ g = g \circ h = e$.</li>
</ol>
<p>
La cardinalidad del grupo es $|G|$ y se le dice el <em>orden</em> de
$\mathbb{G}$. Un grupo es finito si su orden lo es.  Por ejemplo el
o-exclusivo con los valores de verdad es un grupo: $(\{\top, \bot\},
\oplus)$.  Para grupos, aplica lo siguiente:
</p>
<ul>
<li>Cancelaci&oacute;n izquierda: $g \circ h = g \circ i  \Rightarrow h = i$.</li>
<li>Cancelaci&oacute;n derecha: $h \circ g = i \circ g  \Rightarrow h = i$.</li>
<li>Repetici&oacute;n: $g \circ g \in G$, $(g \circ g) \circ g = g \circ (g \circ g) \in G$.</li>
<li>Se escribe $g^2 = g \circ g$, $g^3 = g \circ g^2$, etc.</li>
<li>Entonces $g^i$ refiere a una aplicaci&oacute;n de $\circ$ repetida $i$ veces a $g$.</li>
</ul>
<p>
Un grupo es <em>c&iacute;clico</em> si $\exists g \in G$ tal que
$\forall h \in G \exists i \in \mathbb{Z}, i  0$ tal que $g^i = h$.
Esto quiere decir que todos los elementos de un grupo c&iacute;clico
son potencias de alg&uacute;n elemento de ese grupo. A ese elemento se
le dice el <em>generador</em> del grupo.
</p>
<p>
Sea $i$ el menor entero positivo tal que $g^i = e$. Si existe tal $i$,
su valor es el orden del elemento $h$. Si no existe, se dice que $g$
es de orden infinito. Se escribe $i =$ ord$(g)$.
</p>
<p>
$\mathbb{H}$ es un <em>subgrupo</em> de $\mathbb{G}$ si ambos son
grupos, tienen el mismo operador y los elementos del primero forman un
subconjunto del segundo. Se escribe $\mathbb{H} \sqsubseteq
\mathbb{G}$. El subgrupo generado por un elemento $g$ contiene los
elementos en $H_g = \{ h \mid \exists i$ tal que $h = g^i \}$, donde
$|H_g| = $ord$(g)$ ya que $g$ es el generador de $\mathbb{H}_g$. En
grupos finitos, cualquier elemento genera un subgrupo, por lo cual no
existen elementos de orden infinito en grupos finitos.
</p>
<p>
Un <em>morfismo</em> $f()$ es una funci&oacute;n que mapea los
elementos de un grupo $(G, \circ)$ a los de otro grupo $(H, \bullet)$
sin afectar la estructura: $$f: G \rightarrow H \wedge f (g \circ h) =
f(g) \bullet f(h).$$ En un grupo aplica que $\forall g \in G$ que
$\phi : n \rightarrow g^n$ es un morfismo de los enteros al subgrupo
$H_g$.  Su demostraci&oacute;n requiere que se defina $g^0 = e$ y
$g^{-n} = (g^n)-1$.
</p>
<p>
La relaci&oacute;n de <strong>congruencia</strong> se define a los
n&uacute;meros naturales $\mathbb{N}$ en t&eacute;rminos de conjuntos
$\{ x \mid \exists y \in \mathbb{N}$ as&iacute; que $((y \times a) + b =
x) \}$; se dice que $x$ es congruente con $b$ en m&oacute;dulo $a$ si
$x$ pertenece al mismo conjunto con $b$, en cual caso se escribe $x
\equiv b$ mod $a$. Nota que $a$ es congruente a $b$ en m&oacute;dulo
$n$ si y s&oacute;lo si $(a - b)$ es divisible entre $n$: $a \equiv b$
mod $n \Leftrightarrow n \mid (a - b)$. La relaci&oacute;n de
congruencia se discute en las secciones 4.6&ndash;9 de Concrete
Mathematics.
</p>
<p>
Aplica que $x$ mod $n + y$ mod $n = (x + y)$ mod $n$; la
sumaci&oacute;n modular forma un grupo. Tambi&eacute;n aplica que $x$
mod $n \times y$ mod $n = (x \times y)$ mod $n$; la
multiplicaci&oacute;n modular forma un grupo en aquellos elementos del
conjunto residual de $n$ que son relativamente primos con
$n$, $(i \perp n) \wedge (j \perp n) \Rightarrow ((i \times j)$ mod $n)
\perp n$. 
</p>
<p>
Sea $\mathbb{G} = (G, \circ)$ un grupo y $\mathbb{H} = (H, \circ) \sqsubseteq \mathbb{G}$.
Para $g \in G$, se define el co-conjunto (izquierdo) de $\mathbb{H}$ como
$g \circ H = \{ g \circ h \mid h \in H \}$. Aplica $
\forall g, H: |H| = |g \circ H| \wedge H \cap g \circ H = \emptyset$. Adem&aacute;s,
$$
\forall a, b \in G, H \sqsubseteq G   \Rightarrow 
((a \circ H = b \circ H) \vee ((a \circ H) \cap (b \circ H) = \emptyset)).$$
</p>
<p>
El teorema de Lagrange establece que $(H \sqsubseteq G \wedge |G| = a
 < \infty \wedge |H| = b) \Rightarrow b | a$. Un corollario (es decir,
 consecuencia) de esto es que si $|G| = n$, $\forall g \in G:$ ord$(g)
 | n$. 
</p>
<p>
La funci&oacute;n de Euler se define como
$\phi(n) = |\{ p \in \mathbb{Z}$ tal que $1 < p  n \wedge p \perp n\}|$. 
Para $n$ que son primos (o sea, no tienen divisores aparte de uno y si mismo),
aplica trivialmente que $\phi(n) = n - 1$.
</p>
<p>
El teorema de producto indica que $p \perp q \Rightarrow \phi(p \times
q) = \phi(p) \times \phi(q)$, mientras el teorema de Euler establece que
$a \perp n  \Rightarrow a^{\phi(n)} \equiv 1$ mod $n$. El teorema chica de Fermat
da para un primo $p$ que $a^{p-1} \equiv 1$ mod $p$. Adem&aacute;s aplica que
$n \perp (p \times q) \Leftrightarrow (n \perp p \wedge n \perp q).$
</p>
</div>


       <div class="clase">
	 <h3 id="len">Lenguajes y aut&oacute;matas</h3>
<p>
Lenguajes y aut&oacute;matas son el tema del cap&iacute;tulo 6 de
Grimaldi.
</p>
	 <p>
	   Un <em>alfabeto</em> refiere a un conjunto de
	   s&iacute;mbolos (las <em>letras</em>), mientras una
	   <em>palabra</em> es una sucesi&oacute;n de letras. Por
	   ejemplo, con el alfabeto $\{a, b, c\}$, se puede formar la
	   palabra "cab". La <strong>gram&aacute;tica</strong> son las
	   reglas que definen un <em>lenguaje</em>. Por ejemplo, un
	   lenguaje es aquellas palabras del alfabeto mencionado que
	   contienen por lo menos una letra "a", su largo no excede a
	   cuatro letras y terminan en "c", en cual caso el lenguje
	   corresponde al conjunto finito $\mathcal{L} = \{ ac$,
	   $aac$, $abc$, $bac$, $acc$, $cac$, $aaac$, $aabc$, $baac$,
	   $abac$, $abbc$, $babc$, $bbac$, $accc$, $cacc$, $ccac\}$.
	   </p>
	 <p>
	   Un <em>aut&oacute;mata</em> es un conjunto de <em>estados</em> junto
	   con una funci&oacute;n de transiciones; cuenta con un estado inicial
	   definido y posiblemente uno o m&aacute;s estados finales. Las
	   transiciones pueden activarse seg&uacute;n una <em>entrada</em> o un
	   <em>eventos</em>. T&eacute;cnicamente los s&iacute;mbolos de la
	   entrada se consideran una secuencia de eventos individuales.
	   Un <em>aut&oacute;mata determinista</em> tiene una sola
	   opci&oacute;n por entrada. Uno <em>no determinista</em> tiene por lo
	   menos en un estado hay dos o m&aacute;s posibles transiciones para
	   por lo menos un evento.
	 </p>
	 <p>Una <em>m&aacute;quina Turing</em> (TM) es un <strong>modelo formal
	     de computaci&oacute;n</strong> en t&eacute;rminos de un
	   aut&oacute;mata determinista $M = (K,\Sigma, \delta, s)$ que utiliza
	   una sola estructura de datos: una sucesi&oacute;n de s&iacute;mbolos
	   escrita en una <strong>cinta</strong> (infinita) que permite borrar e
	   imprimir s&iacute;mbolos. $K$ es su conjunto finito
	   de <strong>estados</strong>, donde el estado inicial es $s \in K$.
	   Adem&aacute;s cuenta con estados finales "alto", "s&iacute;" y "no".
	   Opera con un alfabeto finito de <strong>s&iacute;mbolos</strong>
	   $\Sigma$ tal que $\sqcup,\triangleright \in \Sigma$. Su
	   <strong>funci&oacute;n de transici&oacute;n</strong> $$\delta:
	   K\times\Sigma \rightarrow(K \cup
	   \{\text{alto},\text{s&iacute;},\text{no}\})
	   \times\Sigma\times\{\rightarrow,\leftarrow,-\}$$ La cinta
	   est&aacute; siendo accedida por una cabeza lector al cual le
	   llamamos "puntero"; este tiene tres posibles acciones:
	   $\rightarrow$ (desplazar una posici&oacute;n hacia la derecha),
	   $\leftarrow$ (lo mismo pero hacia la izquierda) y
	   $-$ (no moverse).
	 </p>
	 <p>
	   La funci&oacute;n de transici&oacute;n $\delta$ captura el
	   "programa" de la TM. Si el <strong>estado actual</strong> es $q \in
	   K$ y el <em>s&iacute;mbolo actualmente bajo del puntero</em> es
	   $\sigma \in \Sigma$, tenemos $\delta(q,\sigma) = (p, \rho, D)$,
	   donde
          </p>
	 <ul>
	   <li>$p$ es el <strong>estado nuevo</strong>,</li>
	   <li>$\rho$ es el <em>s&iacute;mbolo que ser&aacute; escrito</em> en el lugar de
	     $\sigma$,</li>
	   <li>$D \in \{\rightarrow,\leftarrow,-\}$ indica como mueve del puntero.</li>
	   <li>Si el puntero mueve <em>afuera</em> de la sucesi&oacute;n de entrada a
	     la derecha, el s&iacute;mbolo que es le&iacute;do es siempre $\sqcup$
	     (un s&iacute;mbolo blanco).</li>
	 </ul>
	 <p>
	   Cada programa comienza con la siguiente configuraci&oacute;n: 
	  </p>
	 <ul>
	   <li>la TM en el estado inicial $s \in K$,</li>
	   <li>con la cinta inicializada a contener $\triangleright x$, donde $x$ es una
	     sucesi&oacute;n finita de s&iacute;mbolos en $(\Sigma -\{\sqcup\})^\ast$,</li>
	   <li>el puntero puntando a $\triangleright$ en la cinta.</li>
	 </ul>
	 <p>
	   La secuencia $x$ es la entrada de la m&aacute;quina. Una TM se
	   ha <strong>detenido</strong> al haber llegado a un estado de alto
	   $\{\text{alto},\text{s&iacute;},\text{no}\}$. Si la m&aacute;quina se
	   detuvo en $\text{s&iacute;}$, la
	   m&aacute;quina <strong>acepta</strong> la entrada. Si la
	   m&aacute;quina se detuvo en $\text{no}$, la
	   m&aacute;quina <strong>rechaza</strong> su
	   entrada. La <strong>salida</strong> $M(x)$ de la m&aacute;quina $M$
	   con la entrada $x$ se define como
	  </p>
	 <ul>
	   <li>$M(x) =$ "s&iacute;" si la m&aacute;quina acepta $x$.</li>
	   <li>$M(x) =$ "no" si la m&aacute;quina rechaza $x$.</li>
	   <li>$M(x) = y$ si la m&aacute;quina llega a "alto" y $\triangleright y
	     \sqcup\sqcup\ldots$ es la sucesi&oacute;n escrita en la cinta de
	     $M$ en el momento de detenerse..</li>
	   <li>$M(x) = \nearrow$ si $M$ nunca se detiene con la entrada $x$.</li>
	 </ul>
	 <p>
	   Estudiamos como ejemplo el c&oacute;mputo de $n+1$ dado $n \in
	   \mathbb{Z}$ para $n > 0$ en representaci&oacute;n binaria con por lo menos un cero
	    inicial: $K = \{s, q\}$; $\Sigma = \{0,1,\sqcup,\triangleright\}.$
	</p>
	<table>
	  <tr><td>$p \in K$</td><td>$\sigma \in \Sigma$</td><td>$\delta(p,\sigma)$</td></tr>
	  <tr><td>$s$</td><td>$0$</td><td>$(s,0, \rightarrow)$</td></tr> 
	  <tr><td>$s$</td><td>$1$</td><td>$(s,1,\rightarrow)$</td></tr> 
	  <tr><td>$s$</td><td>$\sqcup$</td><td>$(q, \sqcup, \leftarrow)$</td></tr> 
	  <tr><td>$s$</td><td>$\triangleright$</td><td>$(s, \triangleright, \rightarrow)$</td></tr> 
	  <tr><td>$q$</td><td>$0$</td><td>$(\text{alto},1, -)$</td></tr> 
	  <tr><td>$q$</td><td>$1$</td><td>$(q,0, \leftarrow)$</td></tr>
	  <tr><td>$q$</td><td>$\triangleright$</td><td>$(\text{alto}, \triangleright, \rightarrow)$</td></tr> 
	</table>
        <p>
	  Las m&aacute;quinas Turing son una representaci&oacute;n bastante
	  natural para resolver muchos problemas sobre sucesiones. Por ejemplo,
	  realizan <strong>reconocimiento de
	    lenguajes</strong>. Un <strong>lenguaje</strong> se define como $L
	  \subset (\Sigma-\{\sqcup\})^\ast$, donde el s&iacute;mbolo $\ast$
	  indica que se crea una secuencia con cero o m&aacute;s s&iacute;mbolos
	  que provienen de ese conjunto, permitiendo repeticiones. En el
	  contexto de las m&aacute;quinas Turing, debemos suponer que el
	  alfabeto del lenguaje <strong>no</strong> contiene el s&iacute;mbolo
	  "vac&iacute;o" que llena la cinta al inicio.
	</p>
        <p>
	  Una m&aacute;quina Turing $M$ <strong>decide</strong> el lenguaje $L$
	  si y s&oacute;lo si para toda sucesi&oacute;n $x \in (\Sigma \setminus
	  \{\sqcup\})^\ast$ aplica que si $x \in L$, $M(x) = \text{s&iacute;}$ y si $x
	  \not\in L$, $M(x) = \text{no}$.
	  $$L = a^{\ast} = \{\epsilon, a, aa, aaa, aaaa, \ldots\}.$$
	  La clase de lenguajes decididos por alguna m&aacute;quina Turing son
	  los lenguajes <strong>recursivos</strong>.
	</p>
        <p>
	  Una m&aacute;quina Turing <strong>acepta</strong> un lenguaje $L$ si
	  para toda sucesi&oacute;n $x \in (\Sigma-\{\sqcup\})^\ast$ aplica que
	  si $x \in L$, $M(x) = \text{s&iacute;}$, pero si $x \not\in L$, $M(x) =
	  \nearrow$. Los lenguajes aceptados por alg&uacute;n m&aacute;quina
	  Turing son <strong>recursivamente numerables</strong>. Note que si $L$
	  es recursivo, tambi&eacute;n es recursivamente numerable.
	</p>
       </div>
       <div class="ejercicio">
	 <h3 id="e2">Tarea 2</h3>
	 <p>
	   Pregunta 1: <em>Permutaciones</em> La cantidad de posibles reordenamientos que se puede dar al conjunto $\{a, b, c, d, e, f, g\}$
	   en los cuales el primero en aparecer es 
	   <em><span id="d2.primero">a</span></em> y el &uacute;ltimo es
	   <em><span id="d2.ultimo">g</span></em>:
	   <input type="text" id="r2.1" size="10" value="">
	 </p>
	   <span id="c2.1"></span>
	 <p>
	   Pregunta 2: <em>Combinaciones</em> La cantidad de
           subconjuntos del conjunto $\{1, 2, 3, 4, 5, 6, 7, 8\}$ que
           contienen <span id="d2.k">3</span> elementos pero tienen
           una intersecci&oacute;n vac&iacute;a (es decir,
           ning&uacute;n elemento en com&uacute;n) con
           $\{$<span id="d2.sub">3, 5</span>$\}$:
	   <input type="text" id="r2.2" size="10" value="">
	 </p>
	   <span id="c2.2"></span>
	 <p>
	   Pregunta 3: <em>Sucesiones y recursi&oacute;n</em> El &uacute;ltimo elemento del fragmento inicial de la
	   sucesi&oacute;n de Fibonacci que contiene $k =$ 
	   <span id="d2.fibo">24</span> elementos:
	   <input type="text" id="r2.3" size="10" value="">
	 </p>
	   <span id="c2.3"></span>
	 <p>
	   Pregunta 4: <em>Aut&oacute;matas</em> La salida de la siguiente m&aacute;quina Turing si la entrada es 
	   <span id="d2.turing">10101</span> (ambas sin incluir el
	   $\triangleright$):
	   <input type="text" id="r2.4" size="10" value="">
	   <table>
	     <tr><td>$p \in K$</td><td>$\sigma \in \Sigma$</td><td>$\delta(p,\sigma)$</td></tr>
	     <tr><td>$s$</td><td>$\triangleright$</td><td>$(s, \triangleright, \rightarrow)$</td></tr> 
	     <tr><td>$s$</td><td>$0$</td><td>$(s,0, \rightarrow)$</td></tr> 
	     <tr><td>$s$</td><td>$1$</td><td>$(s,1,\rightarrow)$</td></tr> 
	     <tr><td>$s$</td><td>$\sqcup$</td><td>$(q, \sqcup, \leftarrow)$</td></tr> 
	     <tr><td>$q$</td><td>$0$</td><td>$(t, \sqcup, \leftarrow)$</td></tr> 
	     <tr><td>$q$</td><td>$1$</td><td>$(t ,\sqcup, \leftarrow)$</td></tr>
	     <tr><td>$q$</td><td>$\triangleright$</td><td>$(\text{alto}, \triangleright, \rightarrow)$</td></tr> 
	     <tr><td>$t$</td><td>$\triangleright$</td><td>$(\text{alto}, \triangleright, -)$</td></tr> 
	     <tr><td>$t$</td><td>$0$</td><td>$(\text{alto}, 0, -)$</td></tr> 
	     <tr><td>$t$</td><td>$1$</td><td>$(\text{alto}, 1, -)$</td></tr> 
	   </table>
	 </p>
	   <span id="c2.4"></span>
	 <p>
	   Pregunta 5: <em>Tiempo de ejecuci&oacute;n</em>
	   &iquest;Cu&aacute;ntas veces se eval&uacute;a la
	   funci&oacute;n de transici&oacute;n $\delta$ durante la
	   ejecuci&oacute;n de la TM de la pregunta 4 con esa entrada
	   espec&iacute;fica:
	   <input type="text" id="r2.5" size="10" value="">
	 </p>
	   <span id="c2.5"></span>
	 <div class="calif" id="ce2">
	   <span id="s2"></span>
	   <span id="l2"></span>
	 </div>
	 <h4>Preguntas de verificaci&oacute;n</h4>
	    <p>
	      <em>Discute lo siguiente con los compa&ntilde;eros y con
	      la profesora hasta que est&eacute; todo claro. Conviene
	      consultar el libro de texto (cap&iacute;tulos y
	      secciones indicados en el material de la unidad en esta
	      p&aacute;gina) y hasta buscar por videos en la
	      web. Cuando ya no cabe duda, procede al repaso con los
	      viejos <a href="index.html#exam">ex&aacute;menes</a> de
	      medio curso, comenzando desde el m&aacute;s antiguo ya que es
	      el m&aacute;s f&aacute;cil.</em>
	    </p>
	 <p>
	   &iquest;Qu&eacute; significa permutar? &iquest;Por qu&eacute; son $n!$ permutaciones
	   para $n$ elementos? &iquest;Qu&eacute; pasar&iacute;a a la cantidad de
	   permutaciones si alg&uacute;n elemento se repitiera dos o m&aacute;s
	   veces? &iquest;Para qu&eacute; sirven las permutaciones en la ingenier&iacute;a?
	   (Pregunta 1)
	 </p>
	 <p>
	   &iquest;Para que se les llama <em>combinaciones</em> a los
	   subconjuntos? &iquest;Qu&eacute; explicaci&oacute;n tiene la
	   f&oacute;rmula del coeficiente binomial? &iquest;Por qu&eacute; se
	   llama as&iacute;, de hecho? &iquest;Qu&eacute; relaci&oacute;n
	   tiene el coeficiente binomial con el
	   <a target="_blank" href="https://upload.wikimedia.org/wikipedia/commons/0/0e/Pascals_triangle_30_lines.png">tri&aacute;ngulo
	   de Pascal</a>? &iquest;Por qu&eacute; suman a una potencia de dos
	   todos los renglones del tri&aacute;ngulo? &iquest;Qu&eacute; pasa
	   si se permiten repeticiones de los elementos a la cantidad
	   de posibles combinaciones? &iquest;En qu&eacute; situaciones se
	   aplicar&iacute;a esto en la ingenier&iacute;a? (Pregunta 2)
	 </p>
	 <p>
	   &iquest;Por qu&eacute; se le dice <em>recursiva</em> a la definici&oacute;n de
	   la sucesi&oacute;n de Fibonacci? &iquest;Qu&eacute; tiene que ver la sucesi&oacute;n de Fibonacci
	   con la tasa dorada? &iquest;C&oacute;mo se relacionan estos n&uacute;meros al
	   famoso <a target="_blank" href="https://upload.wikimedia.org/wikipedia/commons/5/5b/Fibonacci_spiral_13.svg">espiral de
	   Fibonacci</a>? <a target="_blank" href="https://oeis.org/">&iquest;Que otras
	   secuencias interesantes existen?</a> &iquest;Se podr&iacute;a variar la
	   definici&oacute;n usando restas o multiplicaciones en lugar de la
	   suma? (Pregunta 3)
	 </p>
	 <p>
	   &iquest;Qui&eacute;n
	   fue <a target="_blank" href="https://upload.wikimedia.org/wikipedia/commons/a/a1/Alan_Turing_Aged_16.jpg">Alan
	   Turing</a>? &iquest;Qu&eacute; hizo de importancia?
	   &iquest;Tendr&iacute;a sentido f&iacute;sicamente construir una
	   m&aacute;quina Turing? &iquest;Qu&eacute; relaci&oacute;n tienen
	   las TM con las computadoras? &iquest;Qu&eacute; hace la TM del
	   ejemplo en el sentido matem&aacute;tico? &iquest;Que hace la TM de
	   la tarea en el sentido matem&aacute;tico? &iquest;C&oacute;mo se
	   ver&iacute;a la tabla de la funci&oacute;n de
	   transici&oacute;n para una TM que reste uno a un
	   n&uacute;mero binario o que divida entre dos, cuatro, etc.?
	   &iquest;Por qu&eacute; es importante el cu&aacute;ntos pasos ocupa
	   una TM con una entrada? &iquest;En t&eacute;rminos de qu&eacute;
	   se pudiera medir el consumo de memoria de una
	   ejecuci&oacute;n de una TM ya que el n&uacute;mero de pasos
	   sirve para medir el tiempo de ejecuci&oacute;n? (Preguntas
	   4 y 5)
	 </p>
       </div>
    </div>
    <div class="unidad">
	<h2 id="graf">Grafos y &aacute;rboles</h2>
	<div class="clase">
	  <h3>Grafos</h3>
	<p>
	  Un <em>grafo</em> $\mathcal{G} $ es un par de conjuntos $\mathcal{G} =
	  (V, E)$.</p><p> $V$ es un conjunto de $n$
	  <strong>v&eacute;rtices</strong> $u, v, w \in V$ mientras
	  $E$ es un conjunto de $m$ <strong>aristas</strong>; $|V| =
	  n$ es el <em>orden</em> del grafo y $|E| = m$ se llama
	  el <em>tama&ntilde;o</em> del grafo. Las aristas son
	  t&iacute;picamente <em>pares de v&eacute;rtices</em>, $\{ u,
	  v \} \in E$, en cual caso $E \subseteq V \times V$ &mdash;
	  se escribe $(u, v)$ como notaci&oacute;n alternativa en vez
	  de representar la arista como un subconjunto tal cual.
	</p>
<p>
Grafos se empiezan a ver desde la secci&oacute;n 7.2 en Grimaldi y son el
tema principal de toda la tercera parte del libro, desde cap&iacute;tulo 11.
</p>
<p>
Los v&eacute;rtices se suelen dibujar como circulos y las aristas como
l&iacute;neas que les conectan uno al otro.
</p>
<img src="img/grafo.png" width=450 alt="Un grafo dibujado">
	<p> 
	  Tambi&eacute;n se puede definir grafos donde el producto es entre
	  m&aacute;s de dos "copias" del conjunto $V$, el cual caso se habla
	  de <em>h&iacute;pergrafos</em>.  El <strong>complemento</strong> de un
	  grafo $\mathcal{G} = (V, E)$ es un grafo con los mismos
	  v&eacute;rtices pero solamente con aquellas aristas que no
	  est&aacute;n en $E$.
	</p>
<p>
Un grafo es <strong>plano</strong>
si se puede <em>dibujar en dos dimensiones</em> as&iacute; que ninguna
arista cruza a otra arista. En un grafo <em>no dirigido</em>, los
v&eacute;rtices $v$ y $w$ tienen un papel igual en la arista $\{v,
u\}$. Si las aristas tienen <em>direcci&oacute;n</em>, $\mathcal{G}$
es
<strong>dirigido</strong> (tambi&eacute;n <em>digrafo</em>).
En una arista dirigida $\langle v, w \rangle$:
<ul>
<li>$v$ es el <em>origen</em> (o inicio) de la arista y</li>
<li>$w$ es el <em>destino</em> (o fin) de la arista.</li>
</ul>
</p>
<p>
Al visualizar grafos dirigidos, las aristas se suelen dibujar como
flechas de su origen a su destino.
</p>
<img src="img/dir_nodir.png" width=400 alt="Un grafo no dirigido y uno dirigido">



<p>
Un <strong>bucle</strong> es una arista <em>reflexiva</em>, donde
coinciden el v&eacute;rtice de origen y el v&eacute;rtice de destino:
$\{v, v\}$ o $\langle v, v\rangle$. Si un grafo $\mathcal{G}$ no cuente
con <em>ning&uacute;n</em> bucle, el grafo es no reflexivo.
</p>


<p>
Adem&aacute;s, $E$ podr&iacute;a ser un <em>multiconjunto</em>: m&aacute;s
  de una arista entre un par de v&eacute;rtices.  Si no se permiten
  aristas m&uacute;ltiples, el grafo es <em>simple</em>. Si se
  asignan <em>pesos</em> $\omega(v, w)$ a las aristas, el grafo
  es <strong>ponderado</strong>. Si se asigna <em>identidad</em> a los
  v&eacute;rtices o las aristas, el grafo
  es <strong>etiquetado</strong>.
</p>
<p>
Dos aristas $\{v_1, v_2\}$ y $\{w_1, w_2\}$ son
  <strong>adyacentes</strong> si tienen un v&eacute;rtice en
com&uacute;n: $$|\{v_1, v_2 \} \cap \{w_1, w_2 \} | \geq 1.$$ Una
arista es <strong>incidente</strong> a un v&eacute;rtice si
&eacute;sta lo une a otro v&eacute;rtice. V&eacute;rtices $v$ y $w$
son <strong>adyacentes</strong> si una arista los une: $ \{v, w\} \in
E$.  V&eacute;rtices adyacentes son
llamados <strong>vecinos</strong>. El conjunto de vecinos de $v$ es
su <em>vecindad</em>, $\Gamma(v)$.
</p>
<p>
La matriz que corresponde a la relaci&oacute;n $E$ se llama
la <strong>matriz de adyacencia</strong> del grafo, $A$. Es necesario
etiquetar los v&eacute;rtices para que sean identificados como $v_1,
v_2, \ldots, v_n$.
<ul>
<li>Para un grafo <em>no dirigido</em> $A$ es <em>sim&eacute;trica</em>.</li>
<li><strong>Multigrafos</strong>: una matriz de enteros $A'$ donde
$a'_{i,j} \geq 0$ es el n&uacute;mero de aristas entre $v_i$ y
$v_j$.</li>
<li>Grafos <strong>ponderados</strong>: una matriz (real) $A$ donde
$a_{i,j}$ es el peso de la arista $\{v_i, v_j\}$ o cero si no hay tal
arista.</li>
</ul>
</p>
<p>
Se puede visualizar una matriz (de adyacencia o lo que sea) asignando
colores a pixeles seg&uacute;n el valor de los elementos; por ejemplo
para una matriz de adyacencia de un grafo simple no dirigido negro
puede significar uno y blanco cero. Si hay pesos, se pueden usar
escalas de grises para rango de pesos.
</p>
<p>
El <strong>grado</strong> $\text{deg}(v)$ es el n&uacute;mero de
aristas incidentes a $v$. Para grafos dirigidos,
<ul>
<li>el <em>grado de salida</em> $\overrightarrow{\text{deg}}(v)$ es el
n&uacute;mero de aristas que tienen su origen en $v$ y</li>
<li>el <em>grado de entrada</em> $\overleftarrow{\text{deg}}(v)$ es el
n&uacute;mero de aristas que tienen su destino en $v$.</li>
</ul>
El grado total de un v&eacute;rtice de un grafo dirigido es
$$\text{deg}(v) = \overleftarrow{\text{deg}}(v) +
\overrightarrow{\text{deg}}(v).$$
</p>
<p>
En un grafo <em>simple no dirigido</em>, el grado $\text{deg}(v_i)$
del v&eacute;rtice $v_i$ es la suma de la $i$&eacute;sima fila de $A$,
$$\displaystyle\sum_{v \in V} \text{deg}(v) = 2 m.$$ En un
grafo <em>simple no reflexivo</em> aplica que $\text{deg}(v) =
|\Gamma(v)|$. Si <em>todos</em> los grados son $k$, el grafo
es <strong>$k$-regular</strong>; un grafo $(n- 1)$-regular se llama un
grafo <em>completo</em> $K_n$.
</p>
<p>
Un grafo <em>bipartito</em> es un grafo $\mathcal{G} = (V, E)$ cuyos
v&eacute;rtices se pueden separar en dos conjuntos $U$ y $Q$ de tal
forma que $U \cap W = \emptyset$ y $U \cup W = V$ y que adem&aacute;s
$$\{u, w\} \in E \Rightarrow (u \in U \wedge w \in W) \vee (u \in W
\wedge w \in U).$$
</p>
<img src="img/bipart.png" width=400 alt="Un grafo bipartito, dibujado dos veces">
<p>En un grafo bipartito completo est&aacute;n
presentes todas las aristas permitidas, $K_{|U|, |W|}$.
</p>
<p>
El n&uacute;mero m&aacute;ximo posible de aristas en un
grafo <em>simple</em> es $$m_{\max} = \binom{n}{2} =
\displaystyle\frac{n(n- 1)}{2}.$$ Para $K_n$, tenemos $m = m_{\max}$,
ya que cuenta con todas las aristas presentes por ser completo.
</p>
<p> La <em>densidad</em> es la proporci&oacute;n de aristas presentes:
$$\delta(\mathcal{G}) = \displaystyle\frac{m}{m_{\max}} =
\displaystyle\frac{m}{\binom{n}{2}} =
\displaystyle\frac{2m}{n(n-1)},$$ es decir el n&uacute;mero de aristas
presentes dividido entre el n&uacute;mero m&aacute;ximo posible de aristas para un
grafo con ese orden $n$.
</p>
<p>  
Un grafo <em>denso</em> tiene $\delta(\mathcal{G}) \approx 1$ y un
grafo <em>escaso</em> tiene $\delta(\mathcal{G}) \ll 1$ (lo de $\ll$
significa "mucho menor"; de la misma manera, $\gg$ significa "mucho
mayor").
</p>
	  <p>
Si se tratara de un grafo <em>dirigido</em>, el n&uacute;mero
m&aacute;ximo de aristas ser&iacute;a $n \times (n - 1)$ tal cual
porque una arista de $v$ a $u$ denotada por $\langle v, u \rangle$
es <em>distinta</em> de la arista de $u$ a $v$ denotada por $\langle
u, v \rangle$.
</p>
	  <p>
Si adem&aacute;s se incluyen aristas <em>reflexivas</em> de un nodo a
si mismo, tipo $(v, v)$.  se puede contar con un total de $n^2$
aristas entre $n$ v&eacute;rtices. Si el grafo no es simple sino
un <em>multigrafo</em>, se puede unir un mismo par de v&eacute;rtices
con m&aacute;s de una arista y el concepto de densidad ya no es el
mismo.
	  </p>
<p>
Una sucesi&oacute;n de aristas adyacentes que empieza en $v$ y termina
en $w$ es un <strong>camino</strong> de $v$ a $w$.
El <strong>largo</strong> de un camino es el <em>n&uacute;mero de
aristas</em> que contiene La <strong>distancia</stronG>
$\text{dist}(v, w)$ entre $v$ y $w$ es el largo m&iacute;nimo de todos
los caminos de $v$ a $w$.  La distancia de un v&eacute;rtice a si
mismo es cero.  El <strong>di&aacute;metro</strong>
$\text{diam}(\mathcal{G})$ de $\mathcal{G}$ es la distancia
m&aacute;xima $\text{diam}(\mathcal{G}) = \max_{v \in V, w \in V}
\text{dist}(v, w)$.
</p>
<p>
Un camino <strong>simple</strong> solamente recorre cada  arista
una sola vez o ninguna. Un <strong>ciclo</strong> es un camino que
regresa a su v&eacute;rtice inicial. Un grafo que no cuente con
ning&uacute;n ciclo es <em>ac&iacute;clico</em>. Entonces, un ciclo
simple empieza y regresa del mismo v&eacute;rtice, pero no visita a
ning&uacute;n otro v&eacute;rtice dos veces. Sin embargo, la
elecci&oacute;n del punto de inicio de un ciclo es arbitrario.
</p>
<p>
Un grafo $\mathcal{G}$ es <strong>conexo</strong> si <em>cada</em> par
  de v&eacute;rtices est&aacute; conectado por un camino. Si por
  algunos $v$ y $w$ no existe ning&uacute;n camino, grafo es
<em>no conexo</em>. $\mathcal{G}$ es <em>fuertemente conexo</em> si
cada par de v&eacute;rtices est&aacute; conectado por <em>al menos
dos</em> caminos disjuntos. Un grafo no conexo se puede dividir en dos
o m&aacute;s
<strong>componentes conexos</strong> que son formados por tales conjuntos de
v&eacute;rtices de distancia definida.
</p>
<p>
$\mathcal{G}' = (V', E')$ es un <strong>subgrafo</strong> de
$\mathcal{G} = (V, E)$ si $V' \subseteq V$ y $E' \subseteq E$ tal que
$$\{v, w\} \in E' \Rightarrow \big((v \in V') \wedge (w \in
V')\big).$$ Si el subgrafo contiene todas las aristas posibles, es un
<strong>subgrafo inducido</strong> por el conjunto $V'$. A un subgrafo
que completo se dice una <strong>camarilla</strong> (ingl&eacute;s:
clique).
</p>
<p>
Un <strong>&aacute;rbol</strong> es un grafo conexo ac&iacute;clico.
Un <strong>&aacute;rbol de expansi&oacute;n</strong> de $\mathcal{G} =
(V, E)$ es un subgrafo que es un &aacute;rbol y contiene todos los
v&eacute;rtices de $\mathcal{G}$; tambi&eacute;n se conoce como
&aacute;rbol cubriente. Si el grafo es <em>ponderado</em>, el
&aacute;rbol de <em>expansi&oacute;n
m&iacute;nima</em> es cualquier &aacute;rbol donde la suma de los pesos
de sus aristas es m&iacute;nima.
Los &aacute;rboles son el tema del cap&iacute;tulo 12 de Grimaldi.
</p>
<p>
Un grafo $\mathcal{G}$ no conexo es un <strong>bosque</strong> si cada componente
conexo de $\mathcal{G}$ es un &aacute;rbol.
</p>
<p>
Grafos son <em>isomorfos</em> si existe una bijecci&oacute;n de los
v&eacute;rtices de uno a los del otro que preserve las aristas.
</p>
<img width="300" src="img/petersen.png" alt="Grafo de Petersen">
<p>
Los tres grafos tienen la misma estructura, llamada el grafo de
Petersen.
</p>
<h4>Grafos en Python</h4>
	<p>
	  Podemos definir con programaci&oacute;n orientada a objetos
	  una clase para representar un grafo; guarda esto en
	  un <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/grafo.py">archivo
	  local llamado <span class="codevar">grafo.py</span></a>
	  Ejecutando Python en la carpeta en la cual guardaste ese
	  archivo, puedes
	  ahora<a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/ejemploDeGrafo.py">
	  usar esa clase</a>.
<h4>Problema de alcance REACHABILITY</h4>
<p>
<em>Entrada</em>: un grafo $\mathcal{G} = (V, E)$ y dos
v&eacute;rtices $v, u \in V$.<br>
<em>Pregunta</em>: &iquest;existe un camino de $v$ a $u$?
</p>
<p>
Tiene un <em>problema complemento</em> (cuya respuesta es "falso" si y
s&oacute;lo si el problema original tiene respuesta "verdad":
&iquest;es verdad que no existe ning&uacute;n camino de $v$ a $u$?
</p>
<p>
El
algoritmo <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/fw.py">Floyd-Warshall</a>
es un algoritmo b&aacute;sico para REACHABILITY que determina los
largos de los
<em>caminos m&aacute;s cortos</em> hasta para grafos ponderados.  Los
pesos tienen que ser <em>no negativos</em> para que funcione.  El
algoritmo construye de una manera incremental estimaciones a los
caminos m&aacute;s cortos entre dos v&eacute;rtices hasta llegar a la
soluci&oacute;n &oacute;ptima. Etiquetemos los v&eacute;rtices de
$\mathcal{G} = (V, E)$ as&iacute; que $V = \{1, 2, \ldots, n\}$.
</p>
<p>
Supongamos que $C(i, j, k)$ construye el camino m&aacute;s corto entre
los v&eacute;rtices $i$ y $j$ pasando <em>solamente</em> por
v&eacute;rtices con etiqueta $\leq k$. Para un camino de $i$ a $j$ con
v&eacute;rtices intermedios con menores o iguales a $k+1$, hay dos
opciones:
<ul>
<li>O el camino m&aacute;s corto con etiquetas $\leq k+1$ utiliza <em>solamente</em>
  v&eacute;rtices con etiquetas $\leq k$.</li>
<li>O existe alg&uacute;n camino que primero va de $i$ a $k + 1$ y
  despu&eacute;s de $k+1$ a $j$ as&iacute; que
  la <em>combinaci&oacute;n</em> de estos dos caminos es m&aacute;s
  corto que cualquier camino que solamente utiliza v&eacute;rtices con
  etiquetas menores a $k+1$.</li>
</ul>
</p>
<p>Aplica que $$C(i, j, k) = \min\{ C(i,j,k-1), C(i,k,k-1) +
  C(k,j,k-1)\}$$ con la condici&oacute;n inicial: $C(i,j,0) = w(i,
  j)$, donde $w(i,j)$ es el peso de $(i, j) \in E$.
</p>
<p>
Para grafos no ponderados se utiliza $C(i, j, 0) = 1$ para cada
arista. Donde no hay arista, se asigna $C(i, j, 0) = \infty$.
</p>
<p>
La computaci&oacute;n de $C$ procede de la siguiente manera: iteremos
primero con $k = 1$, despu&eacute;s con $k=2$, continuando hasta $k =
n$ la formulaci&oacute;n recursiva para cada par $\{i, j\}$.  La
informaci&oacute;n de la iteraci&oacute;n $k$ se puede sobre-escribir
con la de la iteraci&oacute;n $k+1$, para ahorrar espacio. La
complejidad asint&oacute;tica del algoritmo es $\mathcal{O}(n^3)$ y el
uso de memoria es <em>cuadr&aacute;tico</em> (sigue pendiente ver
qu&eacute; significa esto &mdash; viene m&aacute;s adelante en el
curso).
</p>
<p>Otros problemas famosos de grafos involucran la existencia y la
construcci&oacute;n de <strong>ciclos y caminos de Hamilton</strong>, donde 
la entrada es un grafo $\mathcal{G} = (V, E)$.
</p>
<p>
HAMILTONIAN PATH: &iquest;existe un camino $C$ en $\mathcal{G}$ tal que
$C$ visite cada v&eacute;rtice exactamente una vez?<br>
HAMILTONIAN CYCLE: &iquest;existe un ciclo $C$ en $\mathcal{G}$ tal
que $C$ visite cada v&eacute;rtice exactamente una vez?</p>
<img src="img/hamilton.png" width=400 alt="Un ciclo de Hamilton">
<p>
Caminos y ciclos Hamiltonianos son el tema de la secci&oacute;n 11.5 de Grimaldi.
</p>
<h4>Circuitos booleanos</h4>
<p>
Circuitos booleanos son el tema de la secci&oacute;n 15.2 de Grimaldi
&mdash; los llama redes de puertas.
</p>

<ul>
<li>Esencialmente grafos dirigidos no ciclicos.</li>
<li>Los v&eacute;rtices son "puertas" $V = \{1, 2, \ldots, n \}$.</li>
<li>Las etiquetas est&aacute;n asignadas as&iacute; que para cada
arista $\langle i, j \rangle \in E$ aplica que $i < j$.</li>
<li>Una puerta corresponde o a una $x_i$ o $\top$ o $\bot$ o un
conectivo.</li>
<li>Las que corresponden a variables o los valores de verdad tienen
grado de entrada cero.</li>
<li>Las de tipo negaci&oacute;n tienen grado de entrada uno.</li>
<li>Las de $\wedge $ o $\vee $ tienen grado de entrada dos.</li>
<li>La &uacute;ltima puerta $n$ es la salida del circuito.</li>
</ul>
<p>
Los valores de verdad de las distintas puertas se determina con un
procedimiento inductivo as&iacute; que se define el valor para cada
puerta todas las entradas de la cual ya est&aacute;n definidos. Los
circuitos pueden ser representaciones <em>m&aacute;s compactas</em>
que las expresiones: en un circuito se puede compartir subcircuitos.
El <em>teorema de Cook</em> establece que un circuito $R(x)$ est&aacute;
satisfactible si y s&oacute;lo si existe una secuencia de elecciones
tal que la tabla de computaci&oacute;n es aceptante si y s&oacute;lo
si $x \in L$.</p>

<div class="ejercicio">
  <h3 id="e3">Tarea 3</h3>
  <p><em>Los <a target="_blank"
      href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/">ejemplos</a>
      sobre la tarea 3 tambi&eacute;n existen como un <a target="_blank"
      href="https://youtu.be/VzUhE8NVf_s">video</a> que combina las
      seis animaciones y resalta los detalles m&aacute;s relevantes.</em>
    </p>
  
  <p>
Determina lo solicitado abajo para el grafo no dirigido con $V = \{1,
2, 3, 4, 5, 6, 7, 8, 9\}$ y $E = \{ (1, 2), (1, 3), (2, 4), (u, v),
(3, 5), (3, 6), (4, 6), (4, 7), (5, 8), (6, 9), (7, 9) \},$ donde $u$
= <span id="d3.u">7</span> &amp; $v$ = <span id="d3.v">4</span>.
  </p>
<p>
  Pregunta 1: el grado m&aacute;ximo
  <input type="text" id="r3.1" size="10" value="">
</p>
  <span id="c3.1"></span>
  <p>
    Pregunta 2: la densidad
  <input type="text" id="r3.2" size="10" value="">
  </p>
  <span id="c3.2"></span>
  <p>
    Pregunta 3: la distancia entre $1$ y $v$
  <input type="text" id="r3.3" size="10" value="">
  </p>
  <span id="c3.3"></span>
  <p>
    Pregunta 4: el di&aacute;metro
  <input type="text" id="r3.4" size="10" value="">
  </p>
  <span id="c3.4"></span>
  <p>
    Pregunta 5: el tama&ntilde;o ($m$) del subgrafo inducido con $V' = V \setminus \{ u, v \}$
    <input type="text" id="r3.5" size="10" value="">
  <br>
  <span id="c3.5"></span>
  </p>
  <div class="calif" id="ce3">
    <span id="s3"></span>
    <span id="l3"></span>
  </div>
  <h4>Preguntas de verificaci&oacute;n</h4>
    <p>
    <em>Discute lo siguiente con los compa&ntilde;eros y con la
      profesora hasta que est&eacute; todo claro. Conviene consultar
      el libro de texto (cap&iacute;tulos y secciones indicados en el
      material de la unidad en esta p&aacute;gina) y hasta buscar por
      videos en la web. Cuando ya no cabe duda, procede a la siguiente
      parte del material de estudio.</em>
  </p>
  <p>
    &iquest;Qu&eacute; tipo de sistemas se puede modelar con grafos? Inventa
    e investiga ejemplos en tu propia &aacute;rea de ingenier&iacute;a.
  </p>
  <p>
    &iquest;En cu&aacute;les de esos ejemplos se necesita grafos
    dirigidos?  &iquest;En cu&aacute;les se ocupa ponderaci&oacute;n a las
    aristas? &iquest;Hay alguno que ocupe multigrafos? &iquest;Alguno que
    ocupe ser un hipergrafo?
  </p>
  <p>
    &iquest;En qu&eacute; modelos se necesita incluir ciclos? &iquest;En
    qu&eacute; caso, por ejemplo, se ocupar&iacute;a bucles?
    &iquest;Cu&aacute;les son conexos y cu&aacute;les pueden ser desconexos?
  </p>
    <p>
    (Deber&iacute;a ser posible inventar ejemplos para cada caso. Si
    no se te ocurre nada, investiga en l&iacute;nea o en el libro de
    texto.)
    </p>
  <p>
    &iquest;Para qu&eacute; sirve dibujar los grafos?
    &iquest;Qu&eacute; es una buena forma de decidir las posiciones de
    los v&eacute;rtices para que el dibujo salga entendible?
  </p>
  <p>
    &iquest;Para qu&eacute; sirve representar grafos en Python? &iquest;Por
    qu&eacute; no basta con dibujarlos?
  </p>
</div>
</div>

<div class="clase">
<h3 id="prob">Problemas y algoritmos</h3>
<p>
Un <strong>problema</strong> es un <em>conjunto</em> (posiblemente
infinito) de
<em>instancias</em> junto con una <em>pregunta</em> sobre alguna
propiedad de las instancias. Formalmente dicho, es un conjunto de
instancias al cual corresponde un conjunto de soluciones, junto con
una relaci&oacute;n que asocia para cada instancia del problema un
subconjunto de soluciones (posiblemente vac&iacute;o). Se clasifican
en dos grupos:
<ul>
<li>Problemas de <strong>decisi&oacute;n</strong> donde la respuesta
es "s&iacute;" o "no".</li>
<li>Problemas de <strong>optimizaci&oacute;n</strong> donde la
pregunta es del tipo
<ul>
<li>"cu&aacute;l es el mejor valor posible" o</li>
<li>"con qu&eacute; configuraci&oacute;n se obtiene el mejor valor posible".</li>
</ul>
</li>
</ul>
<p>
Con problemas de decisi&oacute;n, la tarea es decidir <strong>s&iacute;
o no</strong> la relaci&oacute;n entre instancias y soluciones asigna
un <em>subconjunto vac&iacute;o</em> a una dada instancia. Si existen
soluciones, la respuesta a la pregunta del problema es "s&iacute;", y
si el subconjunto es vac&iacute;o, la respuesta es "no".
</p>
<p>
Resolver un <strong>problema de decisi&oacute;n</strong> por una TM
= <em>decidir un lenguaje</em> que consiste de representaciones de las
instancias del problema que corresponden a la respuesta "s&iacute;".
En <em>problemas de optimizaci&oacute;n</em> la TM hace el
c&oacute;mputo de una funci&oacute;n apropiada de sucesiones a
sucesiones, representando tanto la entrada como la salida en formato
de sucesiones con un alfabeto adecuado.
</p>
<p>
Dado $\Sigma$ y $L \subseteq \Sigma^\ast$, el
<strong>complemento</strong> de $L$ es $\bar{L} = \Sigma^\ast
\setminus L$. Aplica que  $\bar{A}(x) =$ "s&iacute;" si y
s&oacute;lo si $A(x) =$ "no".
</p>
<p>
La clase TIME$(f(n))$ es el conjunto de lenguajes $L$ tales que una
m&aacute;quina Turing <strong>determinista</strong> decide $L$ en
tiempo $f(n)$. La clase de complejidad NTIME$(f(n))$ es el conjunto de
lenguajes $L$ tales que una m&aacute;quina Turing <strong>no
determinista</strong> decide $L$ en tiempo $f(n)$.
</p>
<p>
El conjunto P contiene todos los lenguajes decididos por las
TM <em>deterministas</em> en tiempo <em>polinomial</em>, P =
$\bigcup_{k>0}$ TIME$(n^k)$. El conjunto NP contiene todos los
lenguajes decididos por m&aacute;quinas Turing <em>no
deterministas</em> en tiempo
<em>polinomial</em>, NP = $\bigcup_{k>0}$ NTIME$(n^k)$.
</p>
<p>
Se dice que un lenguaje $\mathcal{L}$ es <em>completo</em> en su clase
si una TM que decide a $\mathcal{L}$ es capaz de decidir a todos los
dem&aacute;s lenguajes de esa clase, utilizando un TM auxiliar que
realiza una <em>reducci&oacute;n</em> eficiente.
</p>
<h4>Algoritmos</h4>
<p>
Un <strong>algoritmo</strong> es un <em>proceso formal</em>
para <em>encontrar la respuesta</em> correcta a la pregunta de un
problema <em>para una instancia dada</em> de un problema
espec&iacute;fico.
</p>
<ul>
<li>&iquest;C&oacute;mo encontrar un nombre en la gu&iacute;a telef&oacute;nica?</li>
<li>&iquest;C&oacute;mo llegar de mi casa a mi oficina?</li>
<li>&iquest;C&oacute;mo determinar si un dado n&uacute;mero es un n&uacute;mero primo?</li>
</ul>
<p>
Para un problema, por lo general existen varios algoritmos con
diferente nivel de <em>eficiencia</em>. Es decir, diferentes
algoritmos pueden tener diferentes
<strong>tiempos de ejecuci&oacute;n</strong> con la <em>misma</em>
instancia del problema.
</p>
<ul>
<li>Un conjunto $\mathcal{E}$ de las <strong>entradas</strong> del
algoritmo, que representan las instancias del problema y</li>
<li>Un conjunto $\mathcal{S}$ de las <strong>salidas</strong>, que
son los posibles resultados de la ejecuci&oacute;n del algoritmo.</li>
<li>La salida del un <strong>algoritmo determinista</strong> depende
&uacute;nicamente de la entrada: $f: \mathcal{E}
\rightarrow\mathcal{S}$.</li>
<li>Existen tambi&eacute;n algoritmos <strong>probabilistas</strong> o 
  <em>aleatorizados</em> donde <strong>no</strong> es as&iacute;.</li>
</ul>
<p>
Los algoritmos se escribe como sucesiones
de <strong>instrucciones</strong> que
<em>procesan</em> la entrada $\rho \in \mathcal{E}$ para producir el
resultado $\xi \in \mathcal{S}$. Cada instrucci&oacute;n es una
operaci&oacute;n simple que es posible ejecutar con eficiencia y
produce un resultado intermedio &uacute;nico. La sucesi&oacute;n $S$
de instrucciones tiene que ser <strong>finita</strong> y $\forall \rho
\in \mathcal{E}$, si $P$ est&aacute; ejecutada con la entrada $\rho$,
el resultado de la computaci&oacute;n ser&aacute; $f(\rho) \in
\mathcal{S}$. Ser&iacute;a altamente deseable que para todo $\rho \in
\mathcal{E}$, la ejecuci&oacute;n de $S$ terminar&aacute;
despu&eacute;s de un <strong>tiempo finito</strong>.
</p>
<p>
Los algoritmos se implementan como programas de c&oacute;mputo en
diferentes lenguajes de programaci&oacute;n. Un mismo algoritmo se
puede implementar en diferentes lenguajes y para diferentes
plataformas computacionales. Frecuentemente se expresan en
pseudoc&oacute;digo. En este curso se usa Python, lo que es tan
conciso que no hace falta usar pseudoc&oacute;digo.
</p>
<p>
Un algoritmo <strong>recursivo</strong> es un algoritmo donde una
parte del algoritmo o el algoritmo completo utiliza <em>a si
mismo</em> como subrutina. En muchos casos es m&aacute;s f&aacute;cil
entender la funci&oacute;n de un algoritmo recursivo y tambi&eacute;n
demostrar que funcione correctamente. A un algoritmo que en vez de
llamarse a si mismo repite en una manera c&iacute;clica el mismo
c&oacute;digo se le dice <em>iterativo</em>. En muchos casos, el
pseudoc&oacute;digo de un algoritmo recursivo resulta m&aacute;s corto
que el pseudoc&oacute;gido de un algoritmo parecido pero iterativo
para el mismo problema. Cada algoritmo recursivo puede ser convertido
a un algoritmo iterativo (aunque no viceversa), aunque
t&iacute;picamente hace da&ntilde;o a la eficiencia del algoritmo
hacer tal conversi&oacute;n. Depende del problema cu&aacute;l manera
es m&aacute;s eficiente: recursiva o iterativa.
</p>
<p>
Como ejemplo, estudiamos la detecci&oacute;n de
un <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/palindrome.py">pal&iacute;ndromo</a>
que es una cadena de letras (en espa&ntilde;ol, t&iacute;picamente se
ignora los acentos) que se lee igual hacia adelante que hacia
atr&aacute;s, como por ejemplo: "reconocer".
</p>
<p>
Las dos medidas m&aacute;s importantes de la <strong>calidad</strong>
de un algoritmo son
<ul>
<li>el <em>tiempo total de computaci&oacute;n</em>, medido por el n&uacute;mero de
operaciones de c&oacute;mputo realizadas durante la ejecuci&oacute;n del
algoritmo, y</li>
<li>la <em>cantidad de memoria</em> utilizada, medida por la cantidad
y tipo de las variables requeridas.</li>
</ul>
<p>
La notaci&oacute;n para capturar tal informaci&oacute;n es a trav&eacute;s de
<strong>funciones de complejidad</strong>. Para un cierto problema
computacional, existen t&iacute;picamente varias si no una cantidad
infinita de instancias. Para definir el <em>tama&ntilde;o</em> de una
dicha instancia, hay que fijar cu&aacute;l ser&aacute; la <em>unidad
b&aacute;sica</em>de tal c&aacute;lculo. T&iacute;picamente se utiliza
la cantidad de bits, bytes, variables enteras, etc&eacute;tera que se
necesita ocupar para representar el problema en su totalidad en la
memoria de una computadora.
</p>
<p>
La <strong>funci&oacute;n del peor caso</strong> es una funci&oacute;n
de complejidad $f: \mathbb{Z}^+ \rightarrow \mathbb{Z}^+$ tal que para
un valor $n$, el valor $f(n)$ representa el n&uacute;mero de
operaciones b&aacute;sicas para <em>el m&aacute;s dif&iacute;cil</em>
de todas las instancias de tama&ntilde;o $n$.  La &uacute;nica
dificultad es <strong>identificar o construir</strong> esa peor
instancia.
</p>
<p>
  La meta del an&aacute;lisis de algoritmos es evaluar la calidad de
    un algoritmo en comparaci&oacute;n con otros algoritmos o en
    comparaci&oacute;n a la complejidad del problema o alguna cota de
    complejidad conocida.  T&iacute;picamente el conteo de "pasos de
    computaci&oacute;n" falta precisi&oacute;n en el sentido que no es
    claro que cosas se considera operaciones b&aacute;sicas. Por eso
    normalmente se caracteriza la calidad de un algoritmo por la
  <strong>clase de magnitud</strong> de la funci&oacute;n de complejidad y no la
  funci&oacute;n exacta misma.
</p>
<p>
No son interesantes los tiempos de computaci&oacute;n para instancias
peque&ntilde;as, sino instancias grandes. Con una instancia
peque&ntilde;a, normalmente todos los algoritmos producen resultados
r&aacute;pidamente. Por ende se estudia el <strong>crecimiento
asint&oacute;tico</strong>.  Para funciones $f : \mathbb{Z}^+
\rightarrow\mathbb{R}$ y $g: \mathbb{Z}^+ \rightarrow\mathbb{R}$,
escribamos
<ul>
<li>$f(n) \in \mathcal{O}(g(n))$ si $\exists c > 0$ tal que $|f(n)|
\leq c |g(n)|$ para suficientemente grandes valores de $n$,</li>
<li>$f(n) \in \Omega(g(n))$ si $\exists c > 0$ tal que $|f(n)| \geq c
|g(n)|$ para suficientemente grandes valores de $n$,</li>
<li>$f(n) \in \Theta(g(n))$ si $\exists c, c' > 0$ tales que $$c \cdot
|g(n)| \leq |f(n)| \leq c' \cdot |g(n)|$$ para suficientemente grandes
valores de $n$,</li>
<li>$f(n) \in o(g(n))$ si $\displaystyle\lim_{n \rightarrow \infty}
\frac{f(n)}{g(n)} = 0$.</li>
</ul>
</p>
<ul>
<li>$\mathcal{O}(f(n))$ es una <strong>cota superior
asint&oacute;tica</strong> al tiempo de ejecuci&oacute;n.</li>
<li>$\Omega(f(n))$ es una <strong>cota inferior asint&oacute;tica</strong>.</li>
<li>$\Theta(f(n))$ dice que las dos funciones crecen asint&oacute;ticamente iguales.</li>
</ul>
<p>
La notaci&oacute;n $\mathcal{O}$ y la complejidad asint&oacute;tica
son el tema del cap&iacute;tulo 9 de Concrete Mathematics La
complejidad computacional se discute tambi&eacute;n en la
secci&oacute;n 5.7 de Grimaldi y el an&aacute;lisis de algoritmos en
la secci&oacute;n 5.8.
</p>
<p>
<img width="350" 
src="https://i.stack.imgur.com/4U2AF.gif" 
alt="Cotas superior e inferior">
<br><small>Ilustraci&oacute;n simplificada de la situaci&oacute;n: la
curva de arriba nos indica que $f(n) \in \mathcal{O}(g(n))$ y la de
abajo que tambi&eacute;n $f(n) \in \Omega(g(n))$, por lo cual se tiene
que $f(n) \in \Theta{O}(g(n))$.</small><p>
<p>
El s&iacute;mbolo $\in$ se reemplaza frecuentemente con una
igualdad. Las definiciones de crecimiento asint&oacute;tica se
generalizan para funciones de argumentos m&uacute;ltiples y
son <em>transitivas</em>: $$ \left(f(n) \in \mathcal{O}(g(n)) \wedge
g(n) \in \mathcal{O}(h(n))\right) \Rightarrow f(n) \in
\mathcal{O}(h(n))$$ y $$\left(f(n) \in \Omega(g(n)) \wedge g(n) \in
\Omega(h(n))\right) \Rightarrow f(n) \in \Omega(h(n)) $$
</p>
<p>
Como &eacute;ste aplica para $\Omega(f(n))$ y $\mathcal{O}(f(n))$ los
dos, aplica por definici&oacute;n tambi&eacute;n para $\Theta(f(n))$.
</p>
<p>
Es f&aacute;cil formar $\mathcal{O}(f(n))$
de <strong>polinomios</strong> y muchas otras expresiones por observar
que en una suma, el t&eacute;rmino mayor domina el crecimiento:</p><p>
$$ \left(f(n) \in \mathcal{O}(h(n)) \wedge g(n) \in
\mathcal{O}(h(n))\right) \Rightarrow f(n) + g(n) \in \mathcal{O}(h(n))
$$
y
$$g(n) \in \mathcal{O}(f(n)) \Rightarrow f(n) + g(n) \in \mathcal{O}(f(n)).$$
</p>
<p>
Con logaritmos, conviene notar que para cualquier base $b > 0$ y cada
$x > 0$ tal que $x \in \mathbb{R}$, aplica que $\log_b(n) \in
\mathcal{O}(n^x)$. Cambiando la base de un logaritmo, llegamos a tener
$$ \log_{a}(n) = \displaystyle\frac{1}{\log_b(a)} \log_b(n) \in
\Theta(\log_b n), $$ porque $\log_b(a)$ es una constante. Entonces
no hay necesidad de marcar la base en una expresi&oacute;n de
complejidad asint&oacute;tica con logaritmos.
</p>
<p>
Con funciones exponenciales, tenemos que $\forall x > 1$ y $\forall k
> 0$, $ n^k \in \mathcal{O}(x^n)$. Es decir, cada polinomial crece
asint&oacute;ticamente m&aacute;s lentamente que cualquiera
expresi&oacute;n exponencial.
</p>

<img width="500" src="img/funciones.png" alt="Crecimiento de algunas funciones">

<table border="1">
<tr><th colspan="8">Tiempos de ejecuci&oacute;n</th></tr>
<tr><th>&nbsp;</th><th colspan="7">$f(n)$</th><tr>
<tr><th>$n$</th><th>$n$</th><th>$n \log_2 n$</th><th>$n^2$</th><th>$n^3$</th><th>$1,5^n$</th><th>$2^n$</th><th>$n!$</th></tr>
<tr><th>     10</th><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$4$ s</td></tr>
<tr><th>     30</th><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$18$ min</td><td>$10^{25}$ a</td></tr>
<tr><th>     50</th><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td> $11$ min</td><td>$36$ a</td><td>$\approx \infty$</td></tr>
<tr><th>    100</th><td>$\approx 0$</td><td>$\approx 0$</td><td>$\approx 0$</td><td>$1$ s</td><td>$12,892$ a</td><td>$10^{17}$ a</td><td>$\approx \infty$</td></tr>
<tr><th>   1,000</th><td>$\approx 0$</td><td>$\approx 0$</td><td>$1$ s</td><td>$18$ min</td><td>$\approx \infty$</td><td>$\approx \infty$</td><td>$\approx \infty$</td></tr>
<tr><th>  10,000</th><td>$\approx 0$</td><td>$\approx 0$</td><td>$2$ min</td><td>$12$ d</td><td>$\approx \infty$</td><td>$\approx \infty$</td><td>$\approx \infty$</td></tr>
<tr><th> 100,000</th><td>$\approx 0$</td><td>$2$ s</td><td>$3$ h</td><td>$32$ a</td><td>$\approx \infty$</td><td>$\approx \infty$</td><td>$\approx \infty$</td></tr>
<tr><th>1,000,000</th><td>$1$ s</td><td>$20$ s</td><td>$12$ d</td><td>$31,710$ a</td><td>$\approx \infty$</td><td>$\approx \infty$</td><td>$\approx \infty$</td></tr>
</table>
<p>
<small>donde mayor a $10^{25}$ a&ntilde;os se denota como $\approx \infty$ y
menor a un segundo se denota como $\approx 0$.</small>
</p>
<p>
Para analizar desde un pseudoc&oacute;digo la complejidad, t&iacute;picamente se
aplica las reglas siguientes:
<ul>
<li>Asignaci&oacute;n de variables simples toman tiempo $\mathcal{O}(1)$.</li>
<li>Escribir una salida simple toma tiempo $\mathcal{O}(1)$.</li>
<li>Leer una entrada simple toma tiempo $\mathcal{O}(1)$.</li>
<li>Si las complejidades de una sucesi&oacute;n de instrucciones $I_1,
  I_2, \ldots, I_k$ son respectivamente $f_1, f_2, \ldots, f_k$, la
  complejidad total de la sucesi&oacute;n es
$$
\mathcal{O}(f_1 + f_2 + \ldots + f_k) = \mathcal{O}(\max \{f_1, \ldots, f_k\})
$$ 
siempre y cuando $k$ <strong>no dependa</strong> del tama&ntilde;o de la
instancia.</li>
<li>La complejidad de una cl&aacute;usula de condici&oacute;n ($if$) es
  la suma del tiempo de evaluar la condici&oacute;n y la complejidad de
  la alternativa ejecutada.</li>
<li>La complejidad de una repetici&oacute;n
(<span class="codevar">while</span>, <span class="codevar">for</span>, etc.) es
$\mathcal{O}(k (f_t + f_o))$, donde $k$ es el n&uacute;mero de veces
que se repite, $f_t$ es la complejidad de evaluar la condici&oacute;n
de terminar y $f_o$ la complejidad de la sucesi&oacute;n de
operaciones de las cuales consiste una repetici&oacute;n.</li>
<li>La complejidad de tiempo de una <strong>llamada de
subrutina</strong> es la suma del tiempo de calcular sus
par&aacute;metros, el tiempo de asignaci&oacute;n de los
par&aacute;metros y el tiempo de ejecuci&oacute;n de las
instrucci&oacute;nes.</li>
<li>Operaciones aritm&eacute;ticas y asignaciones que procesan
listados o conjuntos tienen complejidad lineal en el tama&ntilde;o su
entrada.</li>
</ul>
</p>
<p>
La complejidad de programas recursivos t&iacute;picamente involucra la
soluci&oacute;n de una <strong>ecuaci&oacute;n diferencial</strong>.
El m&eacute;todo m&aacute;s simple es adivinar una soluci&oacute;n y
verificar si est&aacute; bien la adivinanza.
</p>
</div>
<div class="clase">
<h3>Optimizaci&oacute;n combinatoria</h3>
<p>
Para <strong>problemas de optimizaci&oacute;n</strong>, una instancia
est&aacute; compuesta por
</p>
<ul>
<li>un conjunto de <em>configuraciones</em>,</li>
<li>un conjunto de <em>restricciones</em>, y</li>
<li>una <em>funci&oacute;n objetivo</em> que asigna un valor (real) a cada
instancia.</li>
</ul>
<p>
Optimizaci&oacute;n se discute en el cap&iacute;tulo 13 de Grimaldi.
</p>
<p>Si las configuraciones son discretas, el problema es <strong>combinatorial</strong>.</p>
<p>
La tarea en problemas de optimizaci&oacute;n es identificar
cu&aacute;l de las configuraciones
<strong>factibles</strong> (o sea, las que cumplen con todas las
restricciones) tiene el <strong>mejor</strong> valor de la
funci&oacute;n objetivo.  Depende del problema si el mejor valor es
el <strong>mayor</strong> (problema de <em>maximizaci&oacute;n</em> o
el <strong>menor</strong> (problema de <em>minimizaci&oacute;n</em>).
A la configuraci&oacute;n factible con el mejor valor se llama la
<strong>soluci&oacute;n &oacute;ptima</strong> de la instancia.
</p>
<h4>Problema del viajante (TSP)</h4>
<p>
Caso ponderado: ciclo de Hamilton de costo m&iacute;nimo.</p><p>
TSPD es la problema de decisi&oacute;n que corresponde:<br>
<em>Entrada</em>: un grafo ponderado $\mathcal{G} = (V, E)$ con pesos
en las aristas y una constante $c$.<br>
<em>Pregunta</em>: &iquest;existe un ciclo $C$ en $\mathcal{G}$
tal que $C$ visite cada v&eacute;rtice exactamente una vez y que la suma de
los pesos de las aristas de $C$ sea $\leq c$?
</p>
<h4>$k$-COLOREO</h4>
<p>
El problema de coloreo es el siguiente:<br>
<em>Entrada</em>: un grafo no dirigido $\mathcal{G} = (V, E)$ y un
entero $k > 0$.<br>
<em>Pregunta</em>: &iquest;existe una asignaci&oacute;n de
colores a los v&eacute;rtices de $V$ as&iacute; que ning&uacute;n par
de v&eacute;rtices $v, u \in V$ tal que $\{v, u\}
\in E$ tenga el mismo color?
</p>
<img src="img/coloreo.png" width=300 alt="Coloreo">
<p>
Coloreo se discute en la secci&oacute;n 11.6 de Grimaldi.
</p>
<h4>Isomorfismo de subgrafos</h4>
<p>
<em>Entrada</em>: un grafo no dirigido $\mathcal{G} = (V, E)$ y otro grafo
$\mathcal{G}'$.<br>
<em>Pregunta</em>: &iquest;si $\mathcal{G}$ contiene un subgrafo
isom&oacute;rfico con $\mathcal{G}'$?
</p>
<h4>Problema de la mochila (KNAPSACK)</h4>
<p>
<em>Entrada</em>: una lista de $N$ diferentes art&iacute;culos $\varphi_i
\in \Phi$ y cada objeto tiene una <em>utilidad</em> $\nu(\varphi_i)$ y
un <em>peso</em> $\omega(\varphi_i)$.<br>
<em>Pregunta</em>: &iquest;Qu&eacute; conjunto $M \subseteq \Phi$ de
art&iacute;culo deber&iacute;a uno elegir para tener un valor total
por lo menos $k$ si tiene una mochila que solamente soporta peso hasta
un cierto l&iacute;mite superior $\Psi$. Es decir, con la
restricci&oacute;n 

$$\Psi \geq \displaystyle \sum_{\varphi \in M}
\omega(\varphi),$$ 

se aspira maximizar la utilidad total 

$$\displaystyle \sum_{\varphi \in M} \nu(\varphi) \geq k.$$
</p>
<p>
El problema de la mochila es <strong>NP-completo</strong>, igual como
el TSP (m&aacute;s adelante veremos qu&eacute; quiere decir eso), lo
que se demuestra por un problema de conjuntos (cubierto exacto,
ingl&eacute;s: exact cover). Sin embargo, cada instancia del problema
de la mochila se puede resolver en tiempo $\mathcal{O}(N \cdot \Psi)$.
</p>
<p>
Definamos variables auxiliares $V(w,i)$ que es el valor total
m&aacute;ximo posible seleccionando algunos entre los primeros $i$
art&iacute;culos as&iacute; que su peso total es exactamente $w$.
Cada uno de los $V(w,i)$ con $w=1,\ldots,\Psi$ y $i = 1,\ldots,N$
se puede calcular a trav&eacute;s de la ecuaci&oacute;n recursiva
siguiente: $$V(w,i+1) = \max \{V(w,i), v_{i+1}+V(w-w_{i+1},i)\}$$
donde $V(w,0) = 0$ para todo $w$ y $V(w,i) = - \infty$ si $w \leq 0$.
</p>
<p>
A un algoritmo donde la cota de tiempo de ejecuci&oacute;n es
polinomial en los enteros de la entrada y no sus logaritmos se llama
un algoritmo <strong>pseudo-polinomial</strong>. En este caso, podemos
calcular en tiempo constante un valor de $V(w, i)$ conociendo algunos
otros y en total son $N \Psi$ elementos, por lo cual su tiempo de
ejecuci&oacute;n es $\mathcal{O}(N \cdot \Psi)$ &mdash; por ende es un
algoritmo <em>pseudo-polinomial</em>. La respuesta de la problema de
decisi&oacute;n es "s&iacute;" &uacute;nicamente en el caso que
alg&uacute;n valor $V(w, i)$ en el cuadro sea mayor o igual a $k$.
</p>
<p>
  <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/mochila.py">C&oacute;digo
  en Python para el problema KNAPSACK</a></p>
<h4>Camarilla y conjunto independiente</h4>
<p>
<em>Entrada</em>: un grafo no dirigido $\mathcal{G} = (V, E)$ y un entero $k
> 0$.<br>
CLIQUE: &iquest;existe un subgrafo completo inducido por
el conjunto $C \subseteq V$ tal que $|C| = k$?<br>
INDEPENDENT SET: &iquest;existe un subgrafo inducido por el
conjunto $I \subseteq V$ tal que $|I| = k$ y que no
contenga arista ninguna?</p>
<img src="img/camarilla.png" width=200 alt="Camarilla">
<p>Nota que si $C$ es una camarilla en $\mathcal{G} = (V, E)$, $C$ es
un conjunto independiente en $\bar{\mathcal{G}}$.
</p>
<h4>Acoplamientos y cubiertas</h4>
<p>
Un <em>acoplamiento</em> $\mathcal{M} \subseteq E$ es un
conjunto de <em>aristas no adyacentes</em>.  Se dice que un
v&eacute;rtice $v$ est&aacute; <em>acoplado</em> si hay una arista
incidente a $v$ in $\mathcal{M}$; si no, est&aacute; <em>libre</em>.
Acoplamientos (llamados emparejamientos) se ven en la secci&oacute;n 13.4 de Grimaldi.
</p>
<img src="img/acoplamiento.png" width=250 alt="Acoplamiento">
<p>
Un acoplamiento <em>m&aacute;ximo</em> $\mathcal{M}_{\max{}}$ contiene
  el n&uacute;mero m&aacute;ximo posible de aristas (no es
  necesariamente &uacute;nico), mientras un
  acoplamiento <em>maximal</em> es una donde las aristas $\notin
  \mathcal{M}$ est&aacute;n adyacentes a por lo menos una arista $\in
  \mathcal{M}$. Note que m&aacute;ximo $\Rightarrow$ maximal (pero no
  vice versa).</p>
<p>
El <em>n&uacute;mero de acoplamiento</em> de un grafo es la
cardinalidad de su acoplamiento m&aacute;ximo,
$|\mathcal{M}_{\max{}}|$.< Al n&uacute;mero de v&eacute;rtices libres
en este se llama el <em>d&eacute;ficit</em>. Un
acoplamiento <em>perfecto</em> tiene cero deficit y su
n&uacute;mero de acoplamiento es $\frac{n}{2}$. Cada acoplamiento
perfecto es m&aacute;ximo y maximal.</p>
<p>
Un <em>camino alternante</em> es uno cuyos aristas
  alternativamente pertenecen y no pertenecen a
  $\mathcal{M}$. Un <em>camino aumentante</em> $\mathcal{A}$
  es un camino alternante de un v&eacute;rtice libre $v$ a otro
  v&eacute;rtice libre $u$. Un acoplamiento $\mathcal{M}$ es
  m&aacute;ximo si y s&oacute;lo si no contiene
  <em>ning&uacute;n</em> camino aumentante.
</p>
<p>
Dado un $\mathcal{A}$, podemos intercambiar las aristas en
  $\mathcal{M}$ para las no en $\mathcal{M}$ para construir
  $\mathcal{M}'$. Aplica que $|\mathcal{M}'| = |\mathcal{M}| + 1$ y 
$\mathcal{M}' = \big(\mathcal{M} \setminus (\mathcal{M} \cap
\mathcal{A})\big) \cup \big(\mathcal{A} \setminus (\mathcal{M} \cap
\mathcal{A})\big)$.
</p>
<p>
Una <em>cubierta de aristas</em> es un conjunto $\mathcal{C}_E$ de
aristas as&iacute; que para cada v&eacute;rtice $v \in V$,
$\mathcal{C}_E$ contiene una arista incidente a $v$. Honestamente
ser&iacute;a menos confuso llamarlo cubierta <em>por</em> aristas para
que quede claro que son las aristas que est&aacute;n cubiendo a los
v&eacute;rtices, pero las traducciones de los t&eacute;rminos
matem&aacute;ticos dejan mucho por desear. La cubierta &oacute;ptima es
aquella que tiene la cardinalidad m&iacute;nima.
</p>
<p>
Una <em>cubierta de v&eacute;rtices</em> (o mejor, una
cubirta <em>por</em> v&eacute;rtices) es un conjunto $\mathcal{C}_V$ de
v&eacute;rtices as&iacute; que para cada arista $\{v, w\}$, por lo
menos uno de los v&eacute;rtices incidentes est&aacute; incluido en
$\mathcal{C}_V$.  La meta de suele ser encontrar un conjunto de
cardinalidad <em>m&iacute;nima</em>.  Nota que $I$ es un conjunto
independiente en $\mathcal{G}$ si y s&oacute;lo si $V \setminus I$ es
una cubierta de v&eacute;rtices $\mathcal{G}$.
</p>
<p>El problema <strong>VERTEX COVER</strong> es el siguiente:
<br>
<em>Entrada</em>: un grafo $\mathcal{G} = (V, E)$ no dirigido y un entero $k
> 0$.<br>
<em>Pregunta</em>: &iquest;existe un conjunto de v&eacute;rtices $C
\subseteq V$ con $|C| \leq k$ tal que $\forall
\{v, u\} \in E$, o $v \in C$ o $u \in C$?
</p>
<p>Es un problema NP-completo, por lo cual su versi&oacute;n de
construcci&oacute;n es un problema NP-duro, mientras
tanto <strong>EDGE COVER</strong> (lo mismo, pero para la existencia
de una cubierta de aristas) es polinomial ya que se puede resolver
como una extensi&oacute;n del problema de acoplamiento, que a su vez
puede ser resuelto como un problema de flujo m&aacute;ximo.
</p>
<p>
  El ejemplo muestra en verde una cubierta por v&eacute;rtices y en amarillo
  una cubierta por aristas.
</p>
<img src="img/cubierta.png" width=250 alt="Cubierta">
  
<h4>Flujos y cortes</h4>
<p>
Flujos y cortes son el tema se la secci&oacute;n 13.3 de Grimaldi.
</p>
<p>
Ahora nos concentremos a una clase de problemas muy comunes con grafos
ponderados (y posiblemente dirigidos) con dos v&eacute;rtices
especiales: <strong>fuente</strong> $s$ y <strong>sumidero</strong>
$t$. Se ocupa que el grafo est&eacute; conexo en un sentido
especial: $\forall v \in V$, existe un camino &mdash; dirigido en en
caso de grafos dirigidos &mdash; de la fuente $s$ al sumidero $t$ que
pasa por el v&eacute;rtice $v$. A los pesos de las aristas se les
dice <strong>capacidades</strong> $c(v, w) \geq 0$.
</p>
<img src="img/flujo.png" width=600 alt="Un grafo con capacidades">
<p>
Un <strong>flujo positivo</strong> es una funci&oacute;n $f : V \times
V \rightarrow \mathbb{R}$ as&iacute; que $\forall u, v \in
V: \, 0 \leq f(u, v) \leq c(u, v)$ y
$$\forall u \in V \setminus \{s, t \}: \,
\displaystyle \sum_{v \in V} f(v, u) =
\displaystyle \sum_{v \in V} f(u, v).
$$
</p>
<p>Un <strong>corte</strong> $C \subseteq V$ de $\mathcal{G}$ es una
  <em>partici&oacute;n</em> del conjunto de v&eacute;rtices $V$ en dos
  conjuntos: $C$ y $V \setminus C$. Al cortar un grafo de flujo, se
  exige que $s \in C$ y $t \notin C$. La <strong>capacidad</strong>
  del corte es $$\displaystyle \sum_{v \in C, w \notin C} c(v, w).$$
  El corte <strong>m&iacute;nimo</strong> = un corte cuya capacidad es
  m&iacute;nima; el problema de corte m&iacute;nimo
  es <strong>polinomial</strong>. Adem&aacute;s, la capacidad del
  corte m&iacute;nimo entre dos v&eacute;rtices $s$ y $t$
  es <strong>igual</strong> al flujo m&aacute;ximo entre $s$ y $t$.
  Cuando establecido un flujo en el grafo, la cantidad de flujo que
  cruza un corte es <em>igual para cada corte</em> del grafo. En la
  mayor&iacute;a de las aplicaciones de cortes de grafos, los
  tama&ntilde;os de los dos "lados" del corte, $|C|$ y $|V \setminus
  C|$ no suelen ser arbitrarios.</p>
<p>
El problema de m&aacute;xima bisecci&oacute;n es el siguiente:<br>
<p>
<em>Entrada</em>: un grafo $\mathcal{G} = (V, E)$ (donde $n$ es par) y
un entero $k > 0$.<br>
<em>Pregunta</em>: &iquest;existe un corte $C$ en $\mathcal{G}$ con
capacidad $\geq k$ tal que $|C| = |V \setminus C|$?
</p>
<p>
Dado un grafo dirigido con capacidades en las aristas y un flujo
no-&oacute;ptimo, se puede aumentar el flujo que cruza un corte desde
el lado de $s$ al lado de $t$ o alternativamente por disminuir el
flujo desde el lado de $t$ al lado de $s$. Para empezar, podemos
elegir el <em>flujo cero</em>, donde el flujo por cada arista es cero
&mdash; no rompe con ninguna restricci&oacute;n, por lo cual es un
flujo factible, aunque no &oacute;ptimo.
</p>
<p>
Para aumentar el flujo, buscamos un <strong>camino aumentante</strong>
$C$ de $s$ a $t$ en el cual de puede viajar por las aristas
seg&uacute;n su direcci&oacute;n o <strong>en contra</strong>.  Las
aristas $\langle v, w \rangle$ incluidas ser&aacute;n tales que si se
viaja en la direcci&oacute;n original, aplica que $f(v, w) < c(v, w)$,
pero si se viaja en contra, $f(v, w) > 0$. Definamos una
funci&oacute;n auxiliar
$$ \delta(v, w) = \left \{
\begin{array}{ll} 
c(v, w) - f(v, w) \text{ si } \langle v, w \rangle \in E, \\ 
f(v, w), </td><td>\text{ si } \langle w, v \rangle \in E, \\
\end{array} \right.$$ 
Sea $\delta = \min_{C} \{\delta(v, w)\}$. El flujo se aumenta por
a&ntilde;adir $\delta$ en todos los flujos que van seg&uacute;n la
direcci&oacute;n de las aristas en el camino $C$ y
<strong>restar $\delta$</strong> de todos los flujos que van en contra
en $C$. Este procedimiento se itera hasta que ya no existan caminos
aumentantes. Cuando ya no existe camino aumentante ninguno, el flujo
es
<strong>maximal</strong>. La eficiencia del m&eacute;todo presentado
depende de c&oacute;mo se construye los caminos aumentantes. La mayor
eficiencia se logra por elegir siempre el camino aumentante
de <strong>largo m&iacute;nimo</strong>; el algoritmo que resulta es
polinomial, $\mathcal{O}(nm^2) = \mathcal{O}(n^5)$.  Es posible que
hayan m&aacute;s que un camino de largo m&iacute;nimo &mdash;
aplic&aacute;ndolos todos al mismo paso resulta en un algoritmo de
complejidad asint&oacute;tica $\mathcal{O}(n^3)$.
</p>
<p>
Construyamos un <em>grafo residual</em> que captura las posibilidades
de mejoramiento: $\mathcal{G}_f = (V, E_f)$ del grafo $\mathcal{G} =
(V, E)$ con respeto a $f$ tiene aquellas aristas $\{v, w\} \in E$ para
las cuales $f(v, w) < c(v, w)$ y aquellas donde $f(v, w) >
0$. La <em>capacidad de aumento</em> $c'(v, w)$ vale $c(v, w) - f(v,
w)$ si $\{v, w\} \in E$ y $f(w, v)$ si $\{ w, v \} \in E$. Nota que
cada camino simple entre $s$ y $t$ en el grafo residual
$\mathcal{G}_f$ es un camino aumentante de $\mathcal{G}$.  El valor de
$\delta$ es igual al capacidad de aumento m&iacute;nimo del camino.
</p>
<p>
Para elegir los caminos aumentantes m&aacute;s cortos en el grafo
residual, utilizamos BFS desde $s$.  En subgrafo formado por los
caminos cortos en $\mathcal{G}_f$ se llama la <strong>red de
capas</strong> (ingl&eacute;s: layered network) $\mathcal{G}'_f$.
</p>
<p>
Se asigna a cada v&eacute;rtice un valor de "capa" que es su distancia
desde $s$. Solamente v&eacute;rtices con distancias finitas
est&aacute;n incluidas: $\{v, w\}$ de $\mathcal{G}_f$ se incluye en
$\mathcal{G}'_f$ solamente si el valor de capa de $w$ es el valor de
capa de $v$ m&aacute;s uno. En el grafo $\mathcal{G}'_f$, cada camino
de $s$ a $t$ tiene el mismo largo.
</p>
<p>
El mejor aumento ser&iacute;a igual al flujo m&aacute;ximo en
$\mathcal{G}'_f$, pero en el peor caso es igual en complejidad al
problema original. Entonces construyamos una aproximaci&oacute;n:
definimos el <strong>flujo mayor</strong> en $\mathcal{G}'_f$ como un
flujo que ya no se puede aumentar con caminos que solamente utilizan
aristas que "avanzan" hac&iacute;a $t$. Definamos tambi&eacute;n como
el <strong>flujo posible</strong> de un v&eacute;rtice es el
m&iacute;nimo de la suma de las capacidades de las aristas que entran
y de la suma de las capacidades de las aristas que salen: 

$$v_f =
\min \left\{\displaystyle \sum_{\{u, v\} \in \mathcal{G}'_f} c'(u, v), \,
\displaystyle \sum_{\{v, w\} \in \mathcal{G}'_f} c'(v, w) \right\}.$$


</p>
<p>
El <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/ff.py">algoritmo
de Ford-Fulkerson</a> es entonces el siguiente:
<ol>
<li>Quitar de $\mathcal{G}'_f$ los v&eacute;rtices con flujo
  posible cero y sus aristas adyacentes.</li>
<li>Identificar el v&eacute;rtice $v$ con flujo posible m&iacute;nimo.</li>
<li>Empujar una cantidad de flujo igual al flujo posible de $v$
de $v$ a $t$.</li>
<li>Retirar flujo a $v$ de sus aristas entrantes por construir
  caminos de $s$ a $v$.</li>
<li>Repetir el paso anterior hasta que se satisfaga la demanda de
  flujo de $v$ a $t$.</li>
<li>Actualizar las capacidades de las aristas afectadas.</li>
<li>Memorizar el flujo generado y el camino que toma.</li>
<li>Actualizar los flujos posibles.</li>
<li>Volver a eliminar
  v&eacute;rtices con flujo posible cero &amp; sus aristas
  adyacentes.</li>
<li>Si $s$ y $t$ quedaron fuera, el flujo construido es el flujo
  mayor en $\mathcal{G}'_f$.</li>
<li>Si todav&iacute;a est&aacute;n, repetimos el proceso.</li>
</ol>
</p>
<p>La complejidad asint&oacute;tica se determina de la siguiente
manera: la construcci&oacute;n de $\mathcal{G}'_f$ toma tiempo
$\mathcal{O}(n^2)$, mientras la distancia entre $s$ y $t$ est&aacute;
en el peor caso $\mathcal{O}(n)$.
Cada iteraci&oacute;n de construcci&oacute;n de una red de capas
  $\mathcal{G}'_f$ utiliza caminos m&aacute;s largos que el anterior, por
  lo cual la construcci&oacute;n se repite $\mathcal{O}(n)$ veces.
Las operaciones de empujar y retirar flujo son ambas
  $\mathcal{O}(n)$ y se ejecutan en total $\mathcal{O}(n)$
  veces. Entonces, el algoritmo del flujo mayor tiene complejidad
asint&oacute;tica $\mathcal{O}(n^3)$.
</p>
<p>
El problema de <em>corte m&iacute;nimo</em> (MINCUT) es igual al
problema del flujo m&aacute;ximo: se resuelve por fijar un
v&eacute;rtice $s$ cualquiera y despu&eacute;s resolver el flujo
m&aacute;ximo entre $s$ y todos los otros v&eacute;rtices. El valor
m&iacute;nimo de los flujos m&aacute;ximos corresponde al corte
m&iacute;nimo del grafo entero.  Existen algoritmos polinomiales para
el problema de flujo m&aacute;ximo, y solamente repetimos $n- 1$ veces
su ejecuci&oacute;n; entonces el problema corte m&iacute;nimo
pertenece a P.
</p>
<h4>MAXCUT</h4>
<p>
<em>Entrada</em>: un grafo $\mathcal{G} = (V, E)$ no dirigido y no ponderado y un
entero $k$.<br>
<em>Pregunta</em>: &iquest;existe un corte en $\mathcal{G}$ con
capacidad $\geq k$?
<br>
MAXCUT resulta ser NP-completo. 
</p>
</div>
<div class="ejercicio">
  <h3 id="e4">Tarea 4</h3>
  <p><em>Los <a target="_blank"
      href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/">ejemplos</a>
      sobre la tarea 4 tambi&eacute;n forman parte de
      un <a target="_blank" href="https://youtu.be/Qvou3MXscl4">video</a> que combina esas dos
      animaciones con demostraciones del uso de
      <a target="_blank"  href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/">
	los c&oacute;digos ejemplo</a> de la tarea 4.</em>
    </p>
  <p>
    Pregunta 1: <em>Complejidad asint&oacute;tica</em> Simplifica $\mathcal{O}$(<span id="d4.pol">3<em>n</em><sup>3</sup> - 2<em>n</em><sup>2</sup> + 12<em>n</em> - 8</span>); escribe tu respuesta en el formato <span style="codevar">O(x^d)</span> con el exponente adecuado:
  <input type="text" id="r4.1" size="10" value="">
  <br>
  <span id="c4.1"></span>
  </p>
  <p>
    Pregunta 2: <em>Crecimiento asint&oacute;tico</em> &iquest;Cu&aacute;l de las siguientes tres funciones es la m&aacute;s lenta en t&eacute;rminos de
    crecimiento asint&oacute;tico, $f(n)$, $g(n)$ o $h(n)$ si $f(n)$
    = <span id="d4.f"><em>n</em><sup>2</sup> log <em>n</em></span>, $g(n)$
    = <span id="d4.g">sqrt(<em>n</em>)<em>n</em><sup>3</sup></span> &amp; $h(n)$
    = <span id="d4.h"><em>n</em>log<em>n</em><sup>2</sup></span> (escribe "x(n)" sin
    comillas con la letra en lugar de x siendo el nombre de la
    funci&oacute;n m&aacute;s lenta; <codevar>sqrt</codevar> refiere a
    la ra&iacute;z cuadrada):
  <input type="text" id="r4.2" size="10" value="">
  </p>
  <span id="c4.2"></span>
  <p>
    Pregunta 3: <em>Optimizaci&oacute;n combinatoria</em> Agregando un objeto
    adicional con peso <span id="d4.peso">12</span> y
    valor <span id="d4.valor">17</span> a la instancia del problema de
    la mochila usado en el c&oacute;digo ejemplo,
    &iquest;cu&aacute;nto vale el &oacute;ptimo si el l&iacute;mite de
    peso de la mochila es <span id="d4.limite">32</span>?
  <input type="text" id="r4.3" size="10" value="">
  </p>
  <span id="c4.3"></span>
  <p>
    Pregunta 4: <em>Optimizaci&oacute;n de flujo en redes</em>
   Asignando una capacidad de <span id="d4.cap">12</span> a una arista
   desde <span id="d4.desde">2</span>
   hasta <span id="d4.hasta">5</span> a la instancia del problema de
   flujo m&aacute;ximo, &iquest;cu&aacute;nto vale el
   &oacute;ptimo para $s = 1$ y $t = 4$.
  <input type="text" id="r4.4" size="10" value="">
  </p>
  <span id="c4.4"></span>
  <p>
    Pregunta 5: <em>Modificaci&oacute;n de una instancia</em>
    &iquest;Cu&aacute;nto es el mayor flujo posible dentro de esa
    instancia modificada del problema de flujo m&aacute;ximo si la
    fuente y el sumidero se pueden elegir libremente?
  <input type="text" id="r4.5" size="10" value="">
  </p>
  <span id="c4.5"></span>
  <div class="calif" id="ce4">
    <span id="s4"></span>
    <span id="l4"></span>
  </div>
  <h4>Preguntas de verificaci&oacute;n</h4>
  <p>
    <em>Discute lo siguiente con los compa&ntilde;eros y con la
      profesora hasta que est&eacute; todo claro. Conviene consultar
      el libro de texto (cap&iacute;tulos y secciones indicados en el
      material de la unidad en esta p&aacute;gina) y hasta buscar por
      videos en la web. Cuando ya no cabe duda, procede a la &uacute;ltima
      parte del material de estudio.</em>
  </p>
  <p>
    &iquest;Qu&eacute; es la diferencia fundamental entre problemas de decisi&oacute;n y
    las de optimizaci&oacute;n? Piensa en ejemplos pr&aacute;cticos de los dos tipos
    de problemas en tu &aacute;rea de ingenier&iacute;a.  &iquest;Qu&eacute; es la diferencia
    entre los conceptos "problema" e "instancia"? &iquest;Por qu&eacute; pueden
    existir muchos algoritmos para un mismo problema?
  </p>
  <p>
    &iquest;Qu&eacute; es la diferencia principal entre algoritmos recursivos y
    algoritmos iterativos? &iquest;Por qu&eacute; algunos problemas tienen ambos
    tipos de algoritmos?  &iquest;Para qu&eacute; se estudia la complejidad
    asint&oacute;tica de algoritmos?
  </p>
  <p>
    &iquest;Qu&eacute; significa que una soluci&oacute;n es factible? &iquest;Qu&eacute; significa que
    una soluci&oacute;n es &oacute;ptima? &iquest;Pueden existir m&uacute;ltiples soluciones
    factibles? &iquest;Tiene que ser factible una soluci&oacute;n para que pueda ser
    &oacute;ptima? &iquest;Aplica tambi&eacute;n al rev&eacute;s? &iquest;Pueden existir m&uacute;ltiples
    soluciones &oacute;ptimas?
  </p>
  <p>
    Sin consultar alguna fuente externa, explica en palabras propias y
    dibujos de apoyo en qu&eacute; consisten los siguientes problemas:
    coloreo de grafos, problema de viajante, problema de la mochila,
    camarilla m&aacute;xima, conjunto independiente m&aacute;ximo, acoplamiento
    m&aacute;ximo, cubierta m&iacute;nima por v&eacute;rtices, cubierta m&iacute;nima por aristas,
    flujo m&aacute;ximo, corte m&iacute;nimo, corte m&aacute;ximo.
    </p>
</div>
<div class="clase">
<h3>Estructuras de datos</h3>
<p>
Un paso t&iacute;pico en el dise&ntilde;o de un algoritmo es la
elecci&oacute;n de una <strong>estructura de datos</strong> apropiada para el problema.
Revisemos algunas estructuras que se utiliza en construir algoritmos
eficientes.
</p>
<p>
Un <em>arreglo</em> es una estructura capaz de guardar en un orden
fijo $n$ elementos. Los &iacute;ndices de las posiciones pueden
empezar de cero $a[] = [a_0, a_1, a_2, \ldots, a_{n-1}]$ o uno $b[] =
[b_1, b_2, \ldots, b_{n-1}, b_n]$; en Python comienzan desde cero.  Se
refiere al elemento con &iacute;ndice $k$ como $a[k]$.  El <em>tiempo
de acceso</em> del elemento en posici&oacute;n $k$ en un arreglo es
$\mathcal{O}(1)$. Se asume con los elementos guardados en un arreglo no
est&aacute;n ordenados por ning&uacute;n criterio, si no se indica lo
contrario de forma explc&iacute;cita. La complejidad de identificar si
un arreglo no ordenado $a[]$ contiene un cierto elemento $x$ es
$\mathcal{O}(n)$:
<ul>
<li>Habr&aacute; que comparar cada elemento $a[k]$ con $x$.</li>
<li>Terminar al encontrar igualdad o al llegar al final.</li>
<li>Si el elemento no est&aacute; en el arreglo, se necesita $n$
comparaciones.</li>
</ul>
<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
arreglo = (1, 3, 5, 7) # una tupla es como un arreglo "fijo"
arreglo[1] # se puede consultar, pero no modificar
otro = ("hola", "mundo")
print(otro)
arreglo = 1, 3, 5, 7 # parentesis en realidad son opcionales
arreglo[1] # todo funciona igual
otro = "hola", "mundo" # lo mismo en este caso
print(otro)
]]></script>

<p>
Arreglos sirven bien para situaciones donde el n&uacute;mero de
elementos que se necesita es fijo y conocido o por lo menos que no
varie mucho de repente. Si el tama&ntilde;o no est&aacute; fijo ni
conocido, com&uacute;nmente hay que ajustar el tama&ntilde;o por
reservar en la memoria otro arreglo del tama&ntilde;o deseado y copiar
los contenidos del arreglo actual al nuevo. Si los ajustes de la
capacidad ocurren con mucha frecuencia, el arreglo no es la estructura
adecuada.
</p>
<p>
Si el arreglo est&aacute; ordenado en un orden conocido, un algoritmo
mejor para encontrar un elemento igual a $x$ es la
<a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/bbinaria.py">b&uacute;squeda binaria</a>: comparar $x$ con el elemento
$a[k]$ donde $k = \lfloor\frac{n}{2}\rfloor$ (o $k =
\lceil\frac{n}{2}\rceil$, depende de si los &iacute;ndices comienzan
de cero o uno). Al $a[k]$ se llama el <em>elemento pivote</em>. Si
$a[k] = x$, tuvimos suerte y la b&uacute;squeda ya termin&oacute;. Las
otras opciones son:
<ul>
<li>Si $a[k] < x$ y el arreglo est&aacute; en orden creciente,
habr&aacute; que buscar entre los elementos $a[k+1]$ y el
&uacute;ltimo elemento.</li>
<li>Si $a[k] > x$ y el arreglo est&aacute; en orden creciente,
habr&aacute; que buscar entre el primer elemento y el elemento
$a[k-1]$.</li>
<li>Si $a[k] < x$ y el arreglo est&aacute; en orden decreciente,
habr&aacute; que buscar entre el primer elemento y el elemento
$a[k-1]$.</li>
<li>Si $a[k] > x$ y el arreglo est&aacute; en orden decreciente,
habr&aacute; que buscar entre los elementos $a[k+1]$ y el
&uacute;ltimo elemento.</li>
</ul>
<p>
Entonces, si $i$ es el primer &iacute;ndice del &aacute;rea donde
buscar y $j$ es el &uacute;ltimo &iacute;ndice del
&aacute;rea, <strong>repetimos</strong> el mismo procedimiento de
elecci&oacute;n de $k$ y comparaci&oacute;n con un arreglo $a^{(1)} =
[a_i, a_{i+1}, \ldots, a_{j-1}, a_j]$. El resto del arreglo nunca
ser&aacute; procesado, que nos ofrece un ahorro.  De esta manera, si
el contenido siempre se divide en dos partes de aproximadamente el
mismo tama&ntilde;o, la iteraci&oacute;n termina cuando la parte
consiste de un s&oacute;lo elemento. El peor caso es que el elemento
est&eacute; en la primera o la &uacute;ltima posici&oacute;n del
arreglo o que no est&eacute; incluido. &iquest;Cu&aacute;ntas
divisiones tiene el peor caso?
</p>
<img width="350" src="img/binarysearch.png">
<p>
El tama&ntilde;o de la parte que queda para buscar tiene al
  m&aacute;ximo $\lceil\frac{n}{2}\rceil$ elementos. Al &uacute;ltimo
  nivel el tama&ntilde;o de la parte es uno. Entonces, habr&aacute;
  $\log_2(n)$ divisiones. Cada divisi&oacute;n contiene una
  comparaci&oacute;n de $x$ con un $a[k]$ y la asignaci&oacute;n del
  nuevo &iacute;ndice inferior y el nuevo &iacute;ndice
  superior. Por ende son $3 \log_2(n)$ operaciones y la complejidad
  asint&oacute;tica es $\mathcal{O}(\log n )$.
</p>
<p>
<strong>Listas</strong> son estructuras un poco m&aacute;s avanzadas
que puros arreglos, como t&iacute;picamente permiten ajustes naturales
de su capacidad. Una lista enlazada (ingl&eacute;s: linked list)
consiste de elementos que todos contengan adem&aacute;s de su dato, un
puntero al elemento siguiente. Si el orden de los elementos no
est&aacute; activamente mantenido, es f&aacute;cil agregar un elemento
en la lista:
<ul>
<li>Crear el elemento nuevo.</li>
<li>Inicializar su puntero del siguiente elemento a nulo.</li>
<li>Hacer que el puntero del siguiente del &uacute;ltimo elemento
actualmente en la lista punte al elemento nuevo.</li>
</ul>
<p>
Para acceder una lista, hay que mantener un puntero al primer
elemento. Si tambi&eacute;n se mantiene un puntero al &uacute;ltimo
elemento, a&ntilde;adir elementos cuesta $\mathcal{O}(1)$ unidades de
tiempo, mientras solamente utilizando un puntero al comienzo, se
necesita tiempo $\mathcal{O}(n)$, donde $n$ es el n&uacute;mero de
elementos en la lista.
</p>
<p>
Si uno quiere mantener el orden mientras realizando inserciones y
eliminaciones, hay que primero ubicar el elemento anterior al
punto de operaci&oacute;n en la lista:
<ul>
<li>para <strong>insertar</strong> un elemento nuevo $v$ inmediatamente
  <em>despu&eacute;s</em> del elemento $u$ actualmente en la lista, hay
  que ajustar los punteros tal que el puntero del siguiente
  $v.\text{sig}$ de $v$ tenga el valor de $u.\text{sig}$,
  despu&eacute;s de que se cambia el valor de $u.\text{sig}$ a puntar a
  $v$;</li>
<li>para <strong>eliminar</strong> un elemento $v$, el elemento anterior
  siendo $u$, primero hay que asignar $u.\text{sig} :=
  v.\text{sig}$ y despu&eacute;s simplemente eliminar $v$, a que ya
  no hay referencia de la lista.</li>
</ul>
</p>
<p>
Una lista <strong>doblemente enlazada</strong> tiene adem&aacute;s en
cada elemento un enlace al elemento anterior. Su mantenimiento es un
poco m&aacute;s laborioso por tener que actualizar m&aacute;s punteros
por operaci&oacute;n, pero hay aplicaciones en las cuales su eficacia
es mejor. 
</p>
<p>
En Python todo lo de "puntero al siguiente" funciona de forma
impl&iacute;cita, mientras en lenguajes de m&aacute;s bajo nivel de
abstracci&oacute;n como es el ANSI C se manipulan de forma directa
expl&iacute;citamente.
</p>
<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
datos = [1, 2, 4, 8, 16]
datos[1]
datos[-1] # &uacute;ltimo elemento
datos[3] = 4
datos += [30]
nada = [] # lista sin elementos
len(datos)
datos[1:-1] # sublista sin el primero y el &uacute;ltimo
]]></script>
<p>
Con listas, ganamos tama&ntilde;o din&aacute;mico, pero b&uacute;squedas y
consultas de elementos ahora tienen costo $\mathcal{O}(n)$ mientras
con arreglos tenemos acceso en tiempo $\mathcal{O}(1)$ y tama&ntilde;o
"r&iacute;gido".
</p>
<p>
Una <strong>pila</strong> (ingl&eacute;s: stack) es una lista especial
donde todas las operaciones manipulan el primer elemento de la
lista; se a&ntilde;ade al frente y remueve del frente y se implementa
como una lista enlazada manteniendo un puntero $p$ al primer
elemento. (Conviene visualizar una pila de libros en un escritorio
para entender la operaci&oacute;n: conviene poner libros nuevos encima
de los que ya est&aacute;n en la pila y el &uacute;nico libro
f&aacute;cil de quitar es el que est&eacute; encima de los
dem&aacute;s.)
</p>

<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[ 
pila = [] # pila vac&iacute;a para comenzar 
inicio = 0 # en python el primer &iacute;ndice es cero 
pila.insert(inicio, 'a') # para que agregue al _inicio_ de la lista
pila.insert(inicio, 'b') 
pila.insert(inicio, 'c') 
print(pila) # salen en el orden c, b, a (viejos al final, nuevos al inicio)
sale = pila.pop(inicio) # eliminar del inicio (i.e., el primer elemento)
print(sale) # el elemento eliminado fue c
sale = pila.pop(inicio) # ahora al inicio queda b; lo quitamos
print(pila) # queda puro a en la pila
]]></script>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Pila.svg/400px-Pila.svg.png" alt="Pila" width="250">

<p>Una <strong>cola</strong> (ingl&eacute;s: queue) es una estructura
donde los elementos nuevos llegan al final, pero el procesamiento se
hace desde el primer elemento. Tambi&eacute;n colas est&aacute;n
f&aacute;cilmente implementadas como listas enlazadas, manteniendo un
puntero al comienzo de la cola y otro al final. (Piensa en la forma de
hacer fila en bancos para entender la operaci&oacute;n de una cola.)
</p>

<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[ 
cola = [] # cola vac&iacute;a para comenzar 
inicio = 0
cola.append('a') # al final
cola.append('b') 
cola.append('c') 
cola.append('d') 
print(cola) 
sale = cola.pop(inicio) # eliminar del inicio
print(sale) 
sale = cola.pop(inicio) 
print(cola) 
]]></script>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/Cola.svg/400px-Cola.svg.png" alt="Cola" width="250">
</div>
<div class="clase">
<h3>Algoritmos de ordenamiento</h3>
<p>
Para <strong>ordenar</strong> una lista $L = [\ell_1, \ell_2, \ldots,
\ell_n]$ en orden creciente, se puede definir un
mecanismo <span class="codevar">insertar</span>$(L, i, x)$ que busca
desde el comienzo la posici&oacute;n $i$ en la lista $L$ por un
elemento $\ell_j \leq x$ hac&iacute;a la primera posici&oacute;n, tal
que $j \leq i$ (puedes probar si te sale implementar algo as&iacute;n
en Python). Al encontrar tal elemento, el elemento $x$ estar&aacute;
insertada en la posici&oacute;n justo despu&eacute;s del elemento
$\ell_j$. Si no se encuentra un elemento as&iacute;, se inserta $x$ al
comienzo de la lista.
</p>
<h4>Ordinamiento por inserci&oacute;n</h4>
<p>
El procedimiento de la ordenaci&oacute;n empieza con el primer
elemento de la lista y progresa con una variable indicadora de
posici&oacute;n $i$ hasta el &uacute;ltimo elemento. Para cada
elemento, quitamos $\ell_i$ de la lista y se utiliza
a <span class="codevar">insertar</span>$(L, i, x)$ para volver a
guardarlo.
</p>
<h4>Ordenamiento de burbuja</h4>
<p>
Hay varios algoritmos para ordenar un arreglo, esto siendo uno de los
m&aacute;s b&aacute;sicos y menos eficientes. En ingl&eacute;s se conoce como
<em>bubble sort</em>.
</p>
<ul>
<li>Inicia una variable contadora a cero: $c:=0$.</li>
<li>Comenzando desde
el primer elemento, comp&aacute;ralo con el siguiente.</li>
<li>Si su orden est&aacute;
correcto con respeto a la ordenaci&oacute;n deseada, d&eacute;jalos as&iacute;.</li>
<li>Si no est&aacute;n
en orden, con una variable auxiliar $t$, intercambia sus
valores y incrementa a la contadora, $c:=c + 1$.</li>
<li>Avanza a comparar el segundo con el tercero, repitiendo el mismo procesamiento, 
hasta llegar al final del arreglo.</li>
<li>Si al final, $c \neq 0$, asigna $c:=0$ y comienza de nuevo.</li>
<li>Si al final $c = 0$, el arreglo est&aacute; en la orden deseada.</li>
</ul>
<table>
<tr><th>1</th><td>2</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td>2</td><th>1</th><td>3</td><td>4</td><td>5</td></tr>
<tr><td>2</td><td>3</td><th>1</th><td>4</td><td>5</td></tr>
<tr><td>2</td><td>3</td><td>4</td><th>1</th><td>5</td></tr>
<tr><td>2</td><td>3</td><td>4</td><td>5</td><th>1</th></tr>
<tr><th>2</th><td>3</td><td>4</td><td>5</td><td>1</td></tr>
<tr><td>3</td><th>2</th><td>4</td><td>5</td><td>1</td></tr>
<tr><td>3</td><td>4</td><th>2</th><td>5</td><td>1</td></tr>
<tr><td>3</td><td>4</td><td>5</td><th>2</th><td>1</td></tr>
<tr><td>3</td><td>4</td><td>5</td><td>1</td><th>2</th></tr>
<tr><th>3</th><td>4</td><td>5</td><td>2</td><td>1</td></tr>
<tr><td>4</td><th>3</th><td>5</td><td>2</td><td>1</td></tr>
<tr><td>4</td><td>5</td><th>3</th><td>2</td><td>1</td></tr>
<tr><th>4</th><td>5</td><td>3</td><td>2</td><td>1</td></tr>
<tr><td>5</td><th>4</th><td>3</td><td>2</td><td>1</td></tr>
<tr><th>5</th><td>4</td><td>3</td><td>2</td><td>1</td></tr>
</table>
<h4>Ordenamiento por selecci&oacute;n</h4>
<p>
Dado un arreglo de $n$ elementos, podemos ordenar sus elementos en el
orden creciente con el siguiente procedimiento:
</p>
<ol>
<li>Asigna $i :=$ primer &iacute;ndice del arreglo $a[]$.</li>
<li>Busca entre $i$ y el fin del arreglo el elemento menor.</li>
<li>Denote el &iacute;ndice del mejor elemento por $k$ y guarda su valor 
en una variable auxiliar $t:=a[k]$.</li>
<li>Intercambia los valores de $a[i]$ y $a[k]$: $a[k]:=a[i]$, 
$a[i]:=t$.</li>
<li>Incrementa el &iacute;ndice de posici&oacute;n actual: $i:=i + 1$.</li>
<li>Itera hasta que $i$ est&eacute; en el fin del arreglo.</li>
</ol>
<p>
Es una operaci&oacute;n $\mathcal{O}(n)$ combinar dos partes ordenadas
en un solo arreglo ordenada bajo el mismo criterio. Por ejemplo, si la
entrada son dos partes $A$ y $B$ de n&uacute;meros enteros ordenaros
del menor a mayor, el arreglo combinado se crea por
<ul>
<li>leer el primer elemento de $A$,</li>
<li>leer el primer elemento de $B$,</li>
<li>a&ntilde;adir el <strong>m&iacute;nimo</strong> de estos dos en el arreglo nuevo $C$,</li>
<li>re-emplazar la variable auxiliar utilizada por leer el siguiente
  elemento de su arreglo de origen.</li>
</ul>
</p>
<h4>Ordinamiento por fusi&oacute;n</h4>
<p>
Ordenamiento <strong>por fusi&oacute;n</strong> (ingl&eacute;s:
mergesort) funciona por divisiones parecidas a las de la
b&uacute;squeda binaria. El contenido est&aacute; dividido a dos
partes del mismo tama&ntilde;o (m&aacute;s o menos un elemento): la
primera parte tiene largo $\lfloor\frac{n}{2}\rfloor$ y la segunda
tiene largo $n - \lfloor\frac{n}{2}\rfloor$. Ambas partes est&aacute;n
divididos de nuevo hasta que contengan $k$ elementos, $k \geq 1 \ll
n$. Al llegar al nivel donde el contenido por procesar tiene $k$
elementos, se utiliza otro algoritmo para ordenarlo; opcionalmente se
podr&iacute;a fijar $k = 1$. Dos subarreglos $b_\ell[]$ y $b_r[]$
ordenados est&aacute;n combinados con uso de memoria auxiliar a un
arreglo $b[]$:
<ol>
<li>$i_\ell:=0$, $i_r:=0$ y $i:=0$.</li>
<li>Si $b_\ell[i_\ell] < b_r[i_r]$, $b[i] := b_\ell[i_\ell]$ y despu&eacute;s $i_\ell:=i_\ell + 1$
  y $i:=i + 1$.</li>
<li>Si $b_\ell[i_\ell] \geq b_r[i_r]$, $b[i] := b_r[i_r]$ y despu&eacute;s $i_r:=i_r + 1$ y $i :=i + 1$.</li>
<li>Cuando $i_\ell$ o $i_r$ pasa afuera del subarreglo que  corresponde, copia lo que queda del otro al final.</li>
<li>Mientras todav&iacute;a quedan elementos en los dos, repite la  elecci&oacute;n del elemento menor a guardar en $b[]$.</li>
</ol>
</p>
<h4>Ordenamiento r&aacute;pido</h4>
<p>
La idea del ordenamiento r&aacute;pido (ingl&eacute;s: quicksort) es
tambi&eacute;n dividir el contenido, pero no necesariamente en partes
de tama&ntilde;o igual.  Se elige un <strong>elemento pivote</strong>
$a[k]$ seg&uacute;n alg&uacute;n criterio (existen varias opciones
como elegirlo), y divide el contenido de entrada $a[]$ en dos partes:
una parte donde todos los elementos son menores a $a[k]$ y otra parte
donde son mayores o iguales a $a[k]$ por escanear todo el contenido
una vez. La eficiencia del algoritmo depende de la calidad del pivote.
</p>
<img src="img/pivotes.png" width=300 alt="Ejemplos de malos y buenos pivotes">
<p>
El escaneo se puede implementar con <strong>dos
&iacute;ndices</strong> moviendo el el arreglo, uno del comienzo y
otro del final. El &iacute;ndice del comienzo busca por <em>el primer
elemento con un valor mayor o igual al pivote</em>, mientras el
&iacute;ndice de atr&aacute;s mueve en contra buscando por <em>el
primer elemento menor al pivote</em>. Al encontrar elementos tales
antes de cruzar un &iacute;ndice contra el otro, se <em>intercambia</em>
los dos valores y continua avanzando de las mismas posiciones de los
dos &iacute;ndices. Al <em>cruzar</em>, se ha llegado a la
posici&oacute;n donde cortar el arreglo a las dos partes.
</p>
<p>
Tambi&eacute;n se puede realizar de forma recursiva: se repite el
mismo procedimiento con cada uno de las dos partes.As&iacute; nivel
por nivel resultan ordenadas los subarreglos, y por el procesamiento
hecha ya en los niveles anteriores, todo el arreglo resulta
ordenado.
</p>
<p>
No todas las herramientas computacionales vienen con mecanismos de
ordenamiento ya implementados, pero Python s&iacute; ya los tiene.
</p>

<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
a = (2, 6, 9, 12, 10, 20, 120, 391, 10, 209, 1730, 284, 1, 42, 5)
print(a)
print(a[::-1]) # al rev&eacute;s
print(a[::2]) # cada dos pasos hac&iacute;a adelante
print(a[::-3]) # cada tres pasos hac&iacute;a atr&aacute;s
b = [2, 6, 9, 12, 10, 20, 120, 391, 10, 209, 1730, 284, 1, 42, 5]
b.sort() # esto funciona igual con una lista en lugar de arreglo
b.sort() # ordenar 
print(b)
b[2] = 12
print(b[::-1]) 
print(b[::2])
print(b[::-3]) 
]]></script>

<p>
<a target="_blank" href="https://www.toptal.com/developers/sorting-algorithms">Una visualizaci&oacute;n interactiva de algoritmos de ordenamiento</a>
</p>
</div>


<div class="clase">
<h3>Estructuras ramificadas</h3>
<p>
Un <strong>&aacute;rbol</strong> es un grafo conexo simple no
c&iacute;clico &mdash; de $n$ nodos etiquetados $1, 2,
\ldots, n$ se puede guardar en un arreglo $a[]$ de $n$ posiciones,
donde el valor de $a[i]$ es la etiqueta del nodo padre del
nodo $i$. Otra opci&oacute;n es guardar en cada elemento un
puntero al nodo padre (y posiblemente del padre una
estructura de punteros a sus hijos). &Aacute;rboles son "listas
estructuradas"; se utilizan como &iacute;ndices de bases de
datos. Cada elemento consiste de una <em>clave</em>(no necesariamente
&uacute;nico) y un dato. &Aacute;rboles permiten realizar
eficientemente inserciones, eliminaciones, y b&uacute;squedas.
</p>
<p>
Es necesario que exista un <em>orden</em> sobre el espacio de las
  claves de los elementos. En un <strong>&aacute;rbol
  binario</strong>, cada nodo que no es una hoja tiene al
  m&aacute;ximo dos nodos hijos: su
  hijo <strong>izquierdo</strong> y su hijo
<strong>derecho</strong>.  Si por m&aacute;ximo un nodo
cuenta con solamente un hijo, se dice que el &aacute;rbol est&aacute;
<strong>lleno</strong>.
</p>
<img width="300" src="img/arbol.png" alt="Un ejemplo de un arbol">
<p>
Su uso como &iacute;ndices es relativamente f&aacute;cil
tambi&eacute;n para bases de datos muy grandes, como diferentes ramos
y partes del &aacute;rbol se puede guardar en diferentes
<strong>p&aacute;ginas</strong> de la memoria f&iacute;sica de la
computadora.
</p>
<img width="550" src="img/division.png">
<p>
El problema con &aacute;rboles binarios es que su forma depende del
orden de inserci&oacute;n de los elementos y en el peor caso puede
reducir a casi una lista. A esto se le llama <em>imbalance</em>.
</p>
<img width="500" src="img/imbalance.png" alt="Imbalance en un arbol">
<p>
Existen muchas herramientas en l&iacute;nea que visualizan operaciones
en &aacute;rboles; por
ejemplo <a target="_blank" href="http://btv.melezinek.cz/binary-search-tree.html">http://btv.melezinek.cz/binary-search-tree.html</a>.
</p>
<p>
Una implementaci&oacute;n de un &aacute;rbol simple en Python se pone
en un <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/arbol.py">archivo <span class="codevar">arbol.py</span></a>.
</p>

<script type="syntaxhighlighter" class="brush: python; gutter: false"><![CDATA[
from arbol import Arbol
a = Arbol()
a.agrega(50)
a.agrega(18)
a.agrega(74)
a.agrega(7)
a.agrega(22)
print(a)
]]></script>
<h4>B&uacute;squeda de una clave</h4>
<p>
Utilicemos en los ejemplos enteros positivos como las claves. Para
buscar la hoja con clave $i$, se empieza del ra&iacute;z del
&aacute;rbol y progresa recursivamente al hijo izquierdo si el valor
del ra&iacute;z es <em>mayor</em> a $i$ y al hijo derecho si el valor
es <em>menor o igual</em> a $i$. Cuando la b&uacute;squeda llega a una
hoja, se eval&uacute;a si el valor de la hoja es $i$ o no. Si no es
$i$, el &aacute;rbol no contiene la clave $i$ en ninguna parte.
<a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/ubicar.py">C&oacute;digo
en Python</a>.
</p>
<p>
Un &aacute;rbol est&aacute; <strong>balanceado</strong> si el largo
m&aacute;ximo es $k$, el largo m&iacute;nimo tiene que ser mayor o
igual a $k -1$. En este caso, el n&uacute;mero de <em>hojas</em> del
&aacute;rbol $n = 2^k \leq n< 2^{k + 1}$.
</p>
<p>
La <em>altura</em> de un ramo de un nodo $v$, es decir, un
sub&aacute;rbol la ra&iacute;z de cual es $v$ es la altura de $v$.  La
altura del &aacute;rbol entero es la altura de su ra&iacute;z.  $$
\mathcal{A}(v) = \left \{ \begin{array}{l} 1, \text{ si } v \text{ es una hoja} \\ \max \{\mathcal{A}(\text{izq}(t)),
\mathcal{A}(\text{der}(t))\} + 1, \text{ si } v \text{ es de ruteo.}
\end{array} \right.  $$
</p>
<img width="600" src="img/bt_alt.png" alt="Altura">
<p><a target="_blank"
      href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/arboles/altmin.gif">Animaci&oacute;n
      sobre altura m&iacute;nima de un &aacute;rbol binario</a></p>
<p>
La <em>profundidad</em> de cada nodo del &aacute;rbol: $$
\mathcal{D}(v) = \left \{ \begin{array}{l} 0, \text{ si } v \text{ es la ra&iacute;z}, \\ \mathcal{D}(v.\mathcal{P}) + 1, \text{ en otro caso.}  \end{array} \right.  $$ La profundidad del &aacute;rbol entero
es simplemente $\max_v \mathcal{D}(v)$.  Aplica que $\mathcal{D} =
\mathcal{A} - 1$.
</p>
<img width="600" src="img/bt_prof.png" alt="Profundidad">
<p>
Para <strong>insertar</strong> un elemento nuevo al &aacute;rbol de &iacute;ndice,
<em>primero hay que buscar</em> la ubicaci&oacute;n de la clave del
elemento. Llegando a la hoja $v_h$ donde deber&iacute;a estar la
clave, hay que <em>crear un nodo de ruteo</em> $v_r$
nuevo. La hoja $v_h$ va a ser uno de los hijos del nodo de
ruteo y el otro hijo ser&aacute; un nodo nuevo $v_n$ creado
para el elemento que est&aacute; insertado.
</p>
<p>
Por ejemplo, el elemento menor de $v_h$ y $v_n$ ser&aacute; el hijo
izquierdo y el mayor el hijo derecho. El valor del nodo de ruteo $v_r$
as&iacute; creado ser&aacute; igual al valor de su hijo derecho.
</p>
<img width="300" src="img/insert.png" alt="Insertando una clave">
<p><a target="_blank"
href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/arboles/arboles.html">Ejemplo
interactivo de construcci&oacute;n</a>: las claves entran una por una (siempre por la ra&iacute;z),
yendo las menores al ramo izquierdo y las mayores al ramo derecho.</p>
<img width="600" src="img/bt_example.png" alt="Ejemplo con varias inserciones">
<p>
Para <strong>eliminar</strong> un elemento del &aacute;rbol, hay que
primero ubicar su posici&oacute;n y despu&eacute;s <em>eliminar
adem&aacute;s de la hoja su nodo de ruteo</em> $v_r$ y mover
el otro nodo hijo del nodo de ruteo $v_h$ a la
posici&oacute;n que ocup&oacute; $v_r$.
</p>
<img width="300" src="img/delete.png" alt="Eliminando una clave">
<p>
Las operaciones de insertar y remover claves modifican la forma del
&aacute;rbol. La garant&iacute;a de tiempo de acceso $\mathcal{O}(\log
n)$ est&aacute; solamente v&aacute;lida a
&aacute;rboles <em>balanceados</em>. Un &aacute;rbol
est&aacute; <em>perfectamente balanceado</em> si su estructura es
&oacute;ptima con respeto al largo del camino de la ra&iacute;z a cada
hoja: todas las hojas est&aacute;n en el mismo nivel, es decir, el
largo m&aacute;ximo de tal camino es igual al largo m&iacute;nimo de
tal camino sobre todas las hojas. Esto es solamente posible cuando el
n&uacute;mero de hojas es $2^k$ para $k \in \mathbb{Z}^+$, en que caso
el largo de todos los caminos desde la ra&iacute;z hasta las hojas es
exactamente $k$.
</p>
<p>
Necesitamos operaciones para "recuperar" la forma balanceada
despu&eacute;s de inserciones y eliminaciones de elementos, aunque no
cada operaci&oacute;n causa una falta de balance en el &aacute;rbol.
Estas operaciones se llaman <strong>rotaciones</strong>. La
rotaci&oacute;n adecuada se elige seg&uacute;n las alturas de los
ramos que est&aacute;n fuera de balance, es decir, tienen diferencia
de altura mayor o igual a dos. Si se balancea despu&eacute;s
de <em>cada inserci&oacute;n y eliminaci&oacute;n</em> siempre y
cuando es necesario, la diferencia ser&aacute; siempre menor o igual a
dos.
</p>
<img width="600" src="img/rotate.png" alt="Rotaciones">
<p>
Sean los hijos de $t$ que est&aacute;n fuera de balance $u$ y $v$.
Consideramos primero el caso que $\mathcal{A}(u) \geq \mathcal{A}(v) +
2$.  Hay dos opciones: si $\mathcal{A}(A) \geq \mathcal{A}(B)$, toca
una rotaci&oacute;n simple a la derecha, pero si $\mathcal{A}(A) <
\mathcal{A}(w)$, toca una rotaci&oacute;n doble izquierda-derecha.
</p>
<p>
En el caso que  $\mathcal{A}(u) \leq \mathcal{A}(v) - 2$, 
si $\mathcal{A}(A) \geq \mathcal{A}(B)$, se hace una
rotaci&oacute;n simple a la izquierda, mientras si
$\mathcal{A}(B) < \mathcal{A}(w)$, corresponde una
rotaci&oacute;n doble derecha-izquierda.
</p>
<p>
Con esas rotaciones, ninguna operaci&oacute;n va a aumentar la altura
de un ramo, pero la puede reducir por una unidad. La manera
t&iacute;pica de encontrar el punto de rotaci&oacute;n $t$ es regresar
hac&iacute;a la ra&iacute;z despu&eacute;s de haber operado con una
hoja para verificar si todos los nodos en camino
todav&iacute;a cumplan con la condici&oacute;n de balance.
</p>
<h4>Mont&iacute;culos</h4>
<p>
Un <strong>mont&iacute;culo</strong> (ingl&eacute;s: heap) es una
estructura compuesta por &aacute;rboles. Existen muchas variaciones de
mont&iacute;culos.  La implementaci&oacute;n t&iacute;pica de un
mont&iacute;culo se basa de &aacute;rboles, mientras &aacute;rboles se
puede guardar en arreglos. Entonces, las implementaciones se basan en
arreglos o el uso de elementos enlazados.
</p>
</div>
<div class="clase">
<h3>Almacenaje y manipulaci&oacute;n de grafos</h3>
<p>
Una representaci&oacute;n para un grafo $\mathcal{G} = (V, E)$ de $n$
v&eacute;rtices etiquetados $1, 2, 3, \ldots, n$ es guardar su matriz
de adyacencia como un arreglo bidimensional $n \times n$. Esto es
eficiente s&oacute;lo cuando $\mathcal{G}$ es medianamente denso; si
estuviera muy denso, ser&iacute;a mejor guardar su complemento con
listas de adyacencia. La matriz ocupa $\mathcal{O}(n^2)$ elementos y
si $m$ es mucho menor que $n^2$, la mayor&iacute;a del espacio
reservado tiene el valor cero.
</p>
<p>Para guardar en su lugar <em>listas de adyacencia</em>, se puede
usar un arreglo $a[]$ donde cada elemento de cu&aacute;l es una lista
de largo din&aacute;mico. La idea es que $a[i]$ contenga (las
etiquetas de) los vecinos del v&eacute;rtice $i$. El tama&ntilde;o de
la estructura de listas de adyacencia es $\mathcal{O}(n + m) \leq
\mathcal{O}(m) = \mathcal{O}(n^2)$ (aunque en muchos casos es mucho
menor).
</p>
<p>
Un <strong>recorrido</strong> es un un m&eacute;todo
sistem&aacute;tico para <em>visitar cada v&eacute;rtice</em> (por lo
menos una vez). Una <strong>b&uacute;squeda</strong> es un recorrido
cuyo prop&oacute;sito es
<em>encontrar</em> un v&eacute;rtice del $\mathcal{G}$ que tenga una
cierta propiedad. Algoritmos de recorrido y/o b&uacute;squeda
com&uacute;nmente utilizan
<strong>colas</strong> o <strong>pilas</strong> como estructuras
auxiliares que guian el proceso. Sus usos incluyen los siguientes:
</p>
<ul>
<li>B&uacute;squeda de v&eacute;rtices.</li>
<li>Construcci&oacute;n de caminos.</li>
<li>Computaci&oacute;n distancias.</li>
<li>Detecci&oacute;n de ciclos.</li>
<li>Identificaci&oacute;n de los componentes conexos.</li>
</ul>
<h4>B&uacute;squeda en profundidad DFS</h4>
<p>
Dado $\mathcal{G}$ y un v&eacute;rtice inicial $v \in V$:
</p>
<ol>
<li>Crea una cola vac&iacute;a $\mathcal{L}$.</li>
<li>Asigna $u := v$.</li>
<li>Marca $u$ visitado.</li>
<li>A&ntilde;ade los vecinos <strong>no marcados</strong> de $v$
al <em>comienzo</em> de $\mathcal{L}$.</li>
<li>Quita del comienzo de $\mathcal{L}$ todos los v&eacute;rtices marcados.</li>
<li>Si $\mathcal{L}$ est&aacute; vac&iacute;a, termina.</li>
<li>Asigna $u :=$ el <em>primer</em> v&eacute;rtice en $\mathcal{L}$.</li>
<li>Quita el primer v&eacute;rtice de $\mathcal{L}$ y ll&aacute;malo $v$.</li>
<li>Continua del segundo paso.</li>
</ol>
</p>
<p>
Un recorrido DFS
(<a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/dfs.py">c&oacute;digo
en Python</a>) puede progresar en varias maneras. El orden de visitas
a los v&eacute;rtices depende de c&oacute;mo se elige a cu&aacute;l
vecino se va. Las opciones son "visitar" antes o despu&eacute;s de
llamar la subrutina para los vecinos; si la visita se
realiza <em>antes</em> de la llamada recursiva se llama
el <em>preorden</em>; en el caso de visitar <em>despu&eacute;s</em>,
se llama <em>postorden</em>
(<a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/visit.py">ejemplo
en Python</a>). La complejidad asint&oacute;tica del recorrido DFS es
$\mathcal{O}(n + m)$: cada arista es procesada por m&aacute;ximo una
vez "de ida" y otra "de vuelta", mientras cada v&eacute;rtice es
procesado una vez; los "ya marcados" no ser&aacute;n revisitados.
</p>
<p>
DFS produce una <em>clasificaci&oacute;n</em> de las aristas:
las aristas de &aacute;rbol son las aristas por las cuales progresa el
procedimiento, es decir, en la formulaci&oacute;n recursiva, $w$ fue
visitado por una llamada de $v$ o vice versa. Estas aristas forman
un <em>&aacute;rbol de expansi&oacute;n</em> del componente conexo del
v&eacute;rtice de inicio. Depende de la manera en que se ordena los
vecinos que habr&aacute; que visitar cu&aacute;les aristan
ser&aacute;n aristas de &aacute;rbol.</p>
<ul>
<li>$v$ es el <em>padre</em> (directo o inmediato) de $w$ si
$v$ lanz&oacute; la llamada recursiva para visitar a $w$.</li>
<li>Si $v$ es el padre de $w$, $w$ es <em>hijo</em>
$v$.</li>
<li>Cada v&eacute;rtice, salvo que el v&eacute;rtice de inicio, que se
llama la
<em>ra&iacute;z</em>, tiene un v&eacute;rtice padre &uacute;nico.</li>
<li>El n&uacute;mero de hijos que tiene un v&eacute;rtice puede variar.</li>
</ul>
<p>Se dice que $v$ es un <em>antepasado</em> de $w$ si existe
una sucesi&oacute;n de v&eacute;rtices $v = u_1, u_2, \ldots, u_k = w$
tal que $u_i$ es el padre de $u_{i+1}$. En ese caso, $w$ es
un <em>descendiente</em> de $v$.</p>
<ul>
<li>$k = 2$: $v$ es el padre de $w$, $v$ es el
antepasado <em>inmediato</em> de $w$ y $w$ es un descendiente
inmediato de $v$.</li>
<li>La ra&iacute;z es un antepasado de todos los otros v&eacute;rtices.</li>
<li>Los v&eacute;rtices sin descendientes son <em>hojas</em>.</li>
<li>Una <em>arista procedente</em> conectan
  un antepasado a un descendiente <em>no inmediato</em>.</li>
<li>Una <em>arista retrocedente</em>
  conecta un descendiente a un antepasado <em>no inmediato</em>.</li>
<li>Una <em>arista transversa</em> conecta un
  v&eacute;rtice a otro tal que no son ni antepasados ni descendientes
  uno al otro &mdash; est&aacute;n de diferentes <em>ramos</em> del
  &aacute;rbol.</li>
<li>Las aristas procedentes y retrocedentes son lo mismo en
  un grafo no dirigido.</li>
</ul>
<p>
El <em>nivel</em> de la ra&iacute;z es cero, y el nivel de $v$
es el nivel de su padre m&aacute;s uno. La <em>altura</em> de
cada hoja es cero y la altura de un nodo interior $v$ es el
m&aacute;ximo de las alturas de sus hijos m&aacute;s
uno. El <em>sub&aacute;rbol</em> de $v$ es el &aacute;rbol que es un
subgrafo del &aacute;rbol de expansi&oacute;n donde $v$ es la ra&iacute;z;
solamente v&eacute;rtices que son descendientes de $v$ est&aacute;n
incluidos adem&aacute;s de $v$ mismo.
</p>
<p>
Se puede utilizar un algoritmo de recorrido para determinar los
<em>componentes conexos</em> de un grafo. Un recorrido
efectivamente explora todos los caminos que pasan por $v$. Por iniciar
DFS en el v&eacute;rtice $v$, el conjunto de v&eacute;rtices visitados
por el recorrido corresponde al componente conexo de $v$. Si el grafo
tiene v&eacute;rtices que no pertenecen al componente de $v$, elegimos
uno de esos v&eacute;rtices $u$ y corremos DFS desde $u$ para
encontrar el componente conexo que contiene a $u$. Iterando se
determina todos los componentes conexos.
</p>
<p>
En un grafo conexo, podemos etiquetar las aristas seg&uacute;n un
recorrido DFS:
<ul>
<li>Asignamos al v&eacute;rtice inicial la etiqueta "uno".</li>
<li>Siempre al
visitar a un v&eacute;rtice por la primera vez, le asignamos una etiqueta
num&eacute;rica uno mayor que la &uacute;ltima etiqueta asignada.</li>
<li>Los v&eacute;rtices llegan a tener etiquetas &uacute;nicas en
$[1, n]$.</li>
<li>La etiqueta obtenida es <em>el n&uacute;mero de
inicio</em> $I(v)$.</li>
</ul>
</p>
<p>
Asignamos otra etiqueta a cada v&eacute;rtice tal que la
asignaci&oacute;n ocurre cuando todos los vecinos han sido recurridos,
empezando de $1$. As&iacute; el v&eacute;rtice de inicio tendr&aacute;
la etiqueta $n$.  Estas etiquetas son los <em>n&uacute;meros de
final</em> $F(v)$.  Las $I(v)$ definen el orden previo del
recorrido, mientras las $F(v)$ definen el orden posterior del
recorrido.
</p>
<p>
Al ejecutar el algoritmo iterativo, basta con mantener las dos
contadores. Al ejecutar el algoritmo recursivo, hay que pasar los
valores de las &uacute;ltimas etiquetas asignadas en la llamada
recursiva (iniciar con cero y cero).
</p>
<p>
Una arista $\{v, u\}$ (dirigida) es
<ul>
<li>una <em>arista de &aacute;rbol</em>
si el recorrido primero lleg&oacute; a $u$ desde $v$,</li>
<li>una <em>arista retrocedente</em> si y
  s&oacute;lo si $(I(u) > I(v)) \wedge  (F(u) < F(v))$,</li>
<li>una <em>arista transversa</em> si y
  s&oacute;lo si $(I(u) > I(v)) \wedge  (F(u) > F(v))$, y</li>
<li>una <em>arista procedente</em> si $v$
  es un antepasado de $u$ (esto solamente tiene sentido para
    grafos dirigidos).</li>
</ul>
</p>
<p>
Un grafo no dirigido es $k$-conexo si de cada v&eacute;rtice hay por
lo menos $k$ caminos distintos a cada otro v&eacute;rtice. El
requisito de ser distinto puede ser de parte de
<ul>
<li>o los v&eacute;rtices tal que no pueden pasar por los mismos
  v&eacute;rtices ningunos de los $k$ caminos (ingl&eacute;s: vertex
  connectivity),</li>
<li>o de las aristas tal que no pueden compartir ninguna arista los
  caminos (ingl&eacute;s: edge connectivity).</li>
</ul>
</p>
<p>
Un grafo dirigido es <em>fuertemente conexo</em> si de cada
  uno de sus v&eacute;rtices existe un camino dirigido a cada otro
  v&eacute;rtice. Los componentes fuertemente conexos de un grafo son
  los subgrafos maximales fuertemente conexos.
</p>
<img width="200" src="img/fuerteconexo.png" alt="Componentes fuertemente conexos">
<p>
Los componentes fuertemente conexos de $\mathcal{G} = (V, E)$ determinan una
<em>partici&oacute;n de los v&eacute;rtices</em> de
$\mathcal{G}$ a las clases de equivalencia seg&uacute;n la
relaci&oacute;n de clausura reflexiva y transitiva de la
relaci&oacute;n de aristas $E$.</p>
<p>
Las aristas entre los componentes fuertemente conexos determinan una
orden parcial en el conjunto de componentes. Ese orden parcial se
puede aumentar a un orden lineal por un algoritmo
de <em>ordenaci&oacute;n topol&oacute;gica</em>.
</p>
<h4>Ordenaci&oacute;n topol&oacute;gica</h4>
<p>
Cuando uno realiza un DFS, los v&eacute;rtices de un componente conexo
se quedan en el mismo ramo del &aacute;rbol de expansi&oacute;n. El
v&eacute;rtice que queda como la ra&iacute;z del ramo se dice la
ra&iacute;z del componente.  Nuestra meta ahora es encontrar las
ra&iacute;ces de los componentes seg&uacute;n el orden de su $F(v)$.
</p>
<p>
Al llegar a una ra&iacute;z $v_i$, su componente est&aacute; formado
por los v&eacute;rtices que fueron visitados en el ramo de $v_i$ pero
no fueron clasificados a ninguna ra&iacute;z anterior $v_1, \ldots,
v_{i-1}$. Esto se puede implementar f&aacute;cilmente con una pila
auxiliar $\mathcal{P}$, empujando los v&eacute;rtices en la pila en el
orden de visita en un DFS y al llegar a una ra&iacute;z,
quit&aacute;ndolos del encima de la pila hasta llegar a la ra&iacute;z
misma.  As&iacute; nada m&aacute;s el componente est&aacute; eliminado
de la pila.
</p>
<p>Si el grafo contiene solamente aristas de &aacute;rbol, cada
v&eacute;rtice forma su propio componente. Nota que las aristas
procedentes no tienen ning&uacute;n efecto en los componentes. Para
que una v&eacute;rtice pueda pertenecer en el mismo componente con
otro v&eacute;rtice, tienen que ser conectados por un camino que
contiene aristas retrocedentes o transversas. La ilustraci&oacute;n
muestra las situaciones en las cuales dos v&eacute;rtices (en gris)
pueden pertenecer en el mismo componente fuertemente conexo:
</p>

<img width="200" src="img/compconn.png">

<p>
Las aristas azules son retrocedentes y las aristas verdes transversas.
  Las aristas de &aacute;rbol est&aacute;n dibujados en negro y otros
  v&eacute;rtices (del mismo componente) en blanco.
</p>
<p>
Utilizamos un arreglo auxiliar $\mathcal{A}(v)$ para guadrar un
n&uacute;mero para c&aacute;da v&eacute;rtice encontrado:
$\mathcal{A}(v)$ es el m&iacute;nimo entre los $I(v)$ los $v$ para los
cuales $\exists w$ que es descendiente de $v$ y adem&aacute;s $\{w,
u\}$ es retrocedente o transversal y la ra&iacute;z del componente de
$u$ es un antepasado de $v$.
</p>
<img width="250" src="img/auxcomp.png">
</p>
<p>
<small>La ra&iacute;z del componente est&aacute; dibujado en gris y la
flecha no continua es un camino, no necesariamente una arista
directa.</small>
</p>
<p>Si $\mathcal{A}(v) = I(v)$, sabemos que $v$ es una ra&iacute;z de
un componente. Entonces, $\forall v \in V: \mathcal{A}(v) < I(v)$,
porque $\mathcal{A}(v)$ contiene el valor del $I(v)$ de un
v&eacute;rtice anteriormente recorrido por una arista retrocedente o
transversa o alternativamente un valor de $\mathcal{A}(v)$ est&aacute;
pasado a $v$ por un descendiente. Aplica que $\mathcal{A}(v)$ es el
m&iacute;nimo entre tres conjuntos: los $I(v)$, los $\mathcal{A}(u)$
que contiene aquellos $u$ que son hijos de $v$, y los $I(u)$ para los
cuales $\{v, u\}$ es retrocedente o transversa y adem&aacute;s la
ra&iacute;z del componente de $u$ es un antepasado de $v$.
</p>
<p>
Durante la ejecuci&oacute;n
el <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/tarjan.py">algoritmo
de Tarjan</a>, en la pila auxiliar $\mathcal{P}$ habr&aacute;
v&eacute;rtices los componentes de los cuales no han sido determinados
todav&iacute;a.  Checamos la pila al momento de procesar una arista
retrocedente o transversa $\{v, u\}$ si la ra&iacute;z de $u$ es un
antepasado de $v$.  Si lo es, $u$ est&aacute; en el mismo componente
con $v$ y los dos v&eacute;rtices $v$ y la ra&iacute;z est&aacute;n
todav&iacute;a en la pila.
</p>
<h4>B&uacute;squeda en anchura BFS</h4>
<ol>
<li>Crea una cola vac&iacute;a $\mathcal{L}$.</li>
<li>Asigna $u := v$.</li>
<li>Marca $u$ visitado.</li>
<li>A&ntilde;ade cada v&eacute;rtice <strong>no marcado</strong>
en $\Gamma(v)$ al <em>final</em> de $\mathcal{L}$.</li>
<li>Si $\mathcal{L}$ est&aacute; vac&iacute;a, concluye.</li>
<li>Asigna $u :=$ el <strong>primer</strong> v&eacute;rtice en $\mathcal{L}$.</li>
<li>Continua del tercer paso.</li>
</ol>
<p><a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/bfs.py">C&oacute;digo en Python</a></p>
<p>
Usos del BFS incluyen obviamente la b&uacute;squeda y el
c&aacute;lculo de distancias desde un v&eacute;rtice espec&iacute;fico
(hay que recordar cu&aacute;l v&eacute;rtice puso a cu&aacute;l en la
cola, darle distancia cero al inicial y luego a los dem&aacute;s uno
m&aacute;s el valor de qui&eacute;n lo agreg&oacute;) y la
detecci&oacute;n de ciclos (por ver si se vuelve a un v&eacute;rtice
ya visitado). Tambi&eacute;n permite calcular los componentes conexos
y hasta la detecci&oacute;n de grafos bipartitos (por
coloreo con $k = 2$).
</p>
</div>
<div class="clase">
<h3>Dise&ntilde;o de algoritmos</h3>
<p>
La meta al dise&ntilde;ar un algoritmo para un problema es encontrar
una manera eficiente a llegar a la soluci&oacute;n deseada. El
dise&ntilde;o empieza por buscar un punto de vista adecuado al
problema.  Muchos problemas tienen transformaciones que permiten
pensar en el problema en t&eacute;rminos de otro problema, mientras en
optimizaci&oacute;n, los problemas tienen <em>problemas
duales</em> que tienen la misma soluci&oacute;n pero pueden
resultar m&aacute;s f&aacute;ciles de resolver.
</p>
<p>
Algunos problemas se puede dividir en <strong>subproblemas</strong>
as&iacute; que la soluci&oacute;n del problema entero estar&aacute;
compuesta por las soluciones de sus partes y las partes pueden ser
solucionados (completamente o relativamente) independientemente.  La
composici&oacute;n de tal algoritmo puede ser iterativo o recursivo.
Hay casos donde los mismos subproblemas ocurren varias veces y es
importante evitar tener que resolverlos varias veces.
</p>
<p>
La formaci&oacute;n de una soluci&oacute;n &oacute;ptima por
mejoramiento de una soluci&oacute;n factible. En algunos casos es
mejor hacer cualquier aumento, aunque no sea el mejor ni localmente,
en vez de considerar todas las alternativas para poder despu&eacute;s
elegir vorazmente o con otra heur&iacute;stica una de ellas.
</p>
<p>
En general, algoritmos heur&iacute;sticos pueden llegar al
&oacute;ptimo (global) en algunos casos, mientras en otros casos
terminan en una soluci&oacute;n factible que no es la &oacute;ptima,
pero ninguna de las operaciones de aumento utilizados logra
mejorarla. Este tipo de soluci&oacute;n se llama
un <strong>&oacute;ptimo local</strong>.
</p>
<p>
El m&eacute;todo <strong>dividir y conquistar</strong> divide un
problema grande en varios subproblemas as&iacute; que cada subproblema
tiene la misma pregunta que el problema original, solamente con una
instancia de entrada m&aacute;s simple. Despu&eacute;s se solucionan
todos los subproblemas de una manera recursiva. Las soluciones a los
subproblemas est&aacute;n combinadas a formar una soluci&oacute;n del
problema entero. Dividir-conquistar es el tema de la secci&oacute;n
10.6 de Grimaldi.
</p>
<p>
Para las instancias del tama&ntilde;o m&iacute;nimo, es decir, las que
ya no se divide recursivamente, se utiliza alg&uacute;n procedimiento
de soluci&oacute;n simple. La idea es que el tama&ntilde;o
m&iacute;nimo sea constante y su soluci&oacute;n lineal en su
tama&ntilde;o por lo cual la soluci&oacute;n de tal instancia
tambi&eacute;n es posible en tiempo constante desde el punto de vista
del m&eacute;todo de soluci&oacute;n del problema entero.
</p>
<p>
Para que sea eficiente el m&eacute;todo para el problema entero,
adem&aacute;s de tener un algoritmo de tiempo constante para las
instancias peque&ntilde;as b&aacute;sicas, es importante que
<ul>
<li>el costo computacional de <em>dividir</em> un problema a
  subproblemas sea bajo y</li>
<li>la computaci&oacute;n de <em>juntar</em> las soluciones de los
  subproblemas sea eficiente.</li>
</ul>
<p>
Las divisiones a subproblemas generan un &aacute;rbol abstracto, la
altura de cual determina el n&uacute;mero de niveles de
divisi&oacute;n. Para lograr un &aacute;rbol abstracto balanceado,
normalmente es deseable dividir un problema a subproblemas de
m&aacute;s o menos el mismo tama&ntilde;o en vez de dividir a unos muy
grandes y otros muy peque&ntilde;os.  Un buen ejemplo del
m&eacute;todo dividir y conquistar es ordenamiento por fusi&oacute;que
tiene complejidad asint&oacute;tica $\mathcal{O}(n \log n)$.
</p>
<p>
Como ejemplo, la <strong>cubierta convexa</strong> es
  la <em>regi&oacute;n convexa</em> m&iacute;nima que contiene un dado
  conjunto de puntos en $\mathbb{R}^2$. Una regi&oacute;n es convexa
  si todos los puntos de un segmento de l&iacute;nea que conecta dos
  puntos incluidos en la regi&oacute;n, tambi&eacute;n est&aacute;n
  incluidos en la misma regi&oacute;n.
</p>
<ol>
<li>Dividir el conjunto de puntos en dos subconjuntos de
  aproximadamente el mismo tama&ntilde;o.</li>
<li>Calcular la cubierta de cada parte.</li>
<li>Juntar las soluciones de los subproblemas a una cubierta
  convexa de todo el conjunto.</li>
</ol>
<p> 
La divisi&oacute;n se itera hasta llegar a un s&oacute;lo punto; la cubierta
de un s&oacute;lo punto es el punto mismo.
</p>
<p>
Procedemos a dividir el conjunto en dos partes as&iacute; que uno
est&eacute; completamente a la izquierda del otro por ordenarlos
seg&uacute;n su coordenada $x$ (en tiempo $\mathcal{O}(n \log n)$ para
$n$ puntos). Para juntar dos cubiertas, el caso donde una est&aacute;
completamente a la izquierda de la otra es f&aacute;cil: basta con
buscar dos segmentos de "<strong>puente</strong>" que tocan en cada
cubierta pero no corten ninguna. Tales puentes se encuentra por
examinar en orden los puntos de las dos cubiertas, asegurando que la
l&iacute;nea infinita definida por el segmento entre los dos puntos
elegidos no corta ninguna de las dos cubiertas. Tambi&eacute;n hay que
asegurar que los dos puentes no corten uno al otro.
</p>
<table>
<tr><td><img  width="250" src="img/puntos.png"></td>
<td><img width="250" src="img/puentes.png"></td></tr>
</table>
<p>
Un orden posible para evaluar pares de puntos como candidatos de
puentes es empezar del par donde uno de los puntos maximiza la
coordinada $y$ en otro maximiza (o minimiza) la coordinada $x$.  Hay
que dise&ntilde;ar c&oacute;mo avanzar al elegir nuevos pares
utilizando alguna heur&iacute;stica que observa cu&aacute;les de las
dos cubiertas est&aacute;n cortadas por el candidato actual. Lo
importante es que cada punto est&aacute; visitado por m&aacute;ximo
una vez al buscar uno de los dos puentes.
</p>
<p>
La complejidad es una ecuaci&oacute;n de recursi&oacute;n
$$
S(n) = \left \{\begin{array}{ll} \mathcal{O}(1), &\text{ si } n = 1, \\ 
2S\left(\frac{n}{2}\right) + \mathcal{O}(n),
&\text{ en otro caso},
\end{array} \right.
$$
cuya soluci&oacute;n es $\mathcal{O}(n \log n)$.
</p>
<p>
Como ejemplo, utilizamos el algoritmo de Strassen que es un algoritmo
para multiplicar dos matrices. Sean $A = (a_{ij})$ y $B = (b_{ij})$
matrices de dimensi&oacute;n $n \times n$. 
</p>
<p>
Sabemos que $AB = C =
(c_{ij})$ donde $c_{ij} = \sum_{k = 1}^n a_{ik}b_{kj}$. La
computaci&oacute;n de cada $c_{ij}$ toma tiempo $\Theta(n)$ (por las
$n$ multiplicaciones y las $n-1$ sumaciones) y son exactamente $n^2$
elementos, por lo cual la complejidad asint&oacute;tica del algoritmo
ingenuo es $\Theta(n^3)$.
</p>
<p>
Un mejor algoritmo tiene la siguiente idea; sea $n = k^2$ para
alg&uacute;n entero positivo $k$. Si $k = 1$, utilizamos el
m&eacute;todo ingenuo. En otro caso, divimos las matrices de entrada
en cuatro partes:
</p>
<table>
<tr><td>$A_{11}$</td><td>$A_{12}$</td></tr>
<tr><td>$A_{21}$</td><td>$A_{22}$</td></tr>
</table>
<p>
y hacemos lo mismo para la matriz $B$ as&iacute; que cada parte tiene
dimensi&oacute;n $\frac{n}{2} \times \frac{n}{2}$.  Luego calculamos
multiplicaciones con estas partes,
<ol>
<li>$A_{11}\cdot B_{11}$,</li>
<li>$A_{12}\cdot B_{21}$,</li>
<li>$A_{11}\cdot B_{12}$,</li>
<li>$A_{12}\cdot B_{22}$,</li>
<li>$A_{21}\cdot B_{11}$,</li>
<li>$A_{22}\cdot B_{21}$,</li>
<li>$A_{21}\cdot B_{12}$,</li>
<li>$A_{22}\cdot B_{22}$,</li>
</ol>
y luego sumamos algunos de estos para obtener los pedazos de la matriz producto $C$:
<ol>
<li>$C_{11} = A_{11}\cdot B_{11} + A_{12}\cdot B_{21}$,</li>
<li>$C_{12} = A_{11}\cdot B_{12} + A_{12}\cdot B_{22}$,</li>
<li>$C_{21} = A_{21}\cdot B_{11} + A_{22}\cdot B_{21}$,</li>
<li>$C_{22} = A_{21}\cdot B_{12} + A_{22}\cdot B_{22}$.</li>
</ol>
</p>
<p>
Ahora bien, en el algoritmo de Strassen se hace lo siguiente con menos operaciones:
<ol>
<li>$S_1 = (A_{12} - A_{22}) \cdot (B_{21} + B_{22})$,</li>
<li>$S_2 = (A_{11} + A_{22}) \cdot (B_{11} + B_{22})$,</li>
<li>$S_3 = (A_{11} - A_{21}) \cdot (B_{11} + B_{12})$,</li>
<li>$S_4 = (A_{11} + A_{12}) \cdot B_{22}$,</li>
<li>$S_5 = A_{11} \cdot (B_{12} - B_{22})$,</li>
<li>$S_6 = A_{22} \cdot (B_{21} - B_{11})$,</li>
<li>$S_7 = (A_{21} + A_{22}) \cdot B_{11}$,</li>
<li>$C_{11} = S_1 + S_2 - S_4 + S_6$,</li>
<li>$C_{12} = S_4 + S_5$,</li>
<li>$C_{21} = S_6 + S_7$,</li>
<li>$C_{22} = S_2 - S_3 + S_5 - S_7$.</li>
</ol>
</p>
<h4>Podar-buscar</h4>
<p>
El m&eacute;todo <strong>podar-buscar</strong> (ingl&eacute;s: prune
and search) es parecido a dividir-conquistar, con la diferencia que
despu&eacute;s de dividir, el algoritmo ignora la otra mitad por saber
que la soluci&oacute;n completa se encuentra por solamente procesar en
la otra parte.  Una consecuencia buena es que tampoco hay que unir
soluciones de subproblemas.
</p>
<p>
Como un ejemplo, analicemos la b&uacute;squeda entre $n$ claves de la
clave en posici&oacute;n $i$ en orden decreciente de los datos. Para
$i = \frac{n}{2}$, lo que se busca es la <strong>mediana</strong> del
conjunto. Un algoritmo ingenuo ser&iacute;a buscar el m&iacute;nimo y
eliminarlo $i$ veces, llegando a la complejidad asint&oacute;tica
$\Theta(i\cdot n)$. Aplicando un algoritmo de ordenaci&oacute;n de un
arreglo, llegamos a la complejidad as&iacute;nt&oacute;tica $\Theta(n
\log n)$.</p>
<p>
Solucionar esto por podar-buscar resulta parecido al ordenaci&oacute;n
r&aacute;pida:
<ol>
<li>elegir un elemento pivote $p$;</li>
<li>dividor los elementos en dos conjuntos:
<ul>
<li>$A$ donde las claves son menores a $p$ y</li>
<li>$B$ donde son mayores o iguales;</li>
</ul></li>
<li>continuar de una manera recursiva solamente con uno de los dos
  conjuntos $A$ y $B$;</li>
<li>elegir el conjunto que contiene al elemento $i$&eacute;simo en orden
  decreciente;</li>
<li>para saber d&oacute;nde continuar, basta con comprar $i$ con $|A|$
  y $|B|$.</li>
</ol>
</p>
<p>
El truco en este algoritmo es en la elecci&oacute;n del elemento
pivote as&iacute; que la divisi&oacute;n sea buena.  Queremos asegurar
que exista una constante $q$ tal que $\frac{1}{2} \leq q < 1$
as&iacute; que el conjunto mayor de $A$ y $B$ contiene $nq$
elementos.  As&iacute; podr&iacute;amos llegar a la complejidad
$$
T(n) = T(qn) + \Theta(n) \leq c n \displaystyle \sum_{i = 0}^\infty q^i =  \frac{cn}{1 - q} = \mathcal{O}(n).
$$
</p>
<p>
La elecci&oacute;n del pivote es como sigue:
<ol>
<li>Divide los elementos en grupos de cinco (o menos en el &uacute;ltimo).</li>
<li>Denota el n&uacute;mero de grupos por $k = \lceil\frac{n}{5}\rceil$.</li>
<li>Ordena en tiempo $\mathcal{O}{5} \in \mathcal{O}{1}$ cada grupo.</li>
<li>Elige la mediana de cada grupo.</li>
<li>Entre las $k$ medianas, elige su mediana $p$ recursivamente.</li>
<li>El elemento $p$ ser&aacute; el pivote.</li>
</ol>
<p>
De esta manera podemos asegurar que por lo menos $\lfloor \frac{n}{10}
\rfloor$ medianas son mayores a $p$ y para cada mediana mayor a $p$
hay dos elementos mayores m&aacute;s en su grupo, por lo cual el
n&uacute;mero m&aacute;ximo de elementos menores a $p$ son $$ 3\lfloor
\frac{n}{10} \rfloor < \frac{3}{4}n$$ para $n \geq 20$.
Tambi&eacute;n sabemos que el n&uacute;mero de elementos mayores a $p$
es por m&aacute;ximo $\frac{3}{4}n$ para $n \geq 20$, por lo cual
aplica que $\frac{n}{4} \leq p \leq \frac{3n}{4}$ para $n \geq
20$.
</p>
<ul>
<li>$|M| = \lceil \frac{n}{5} \rceil$.</li>
<li>La llamada recursiva <span class="codevar">pivote</span>$(\lceil
  \frac{|M|}{2} \rceil, M)$ toma tiempo $T(\lceil \frac{n}{5}
  \rceil)$ por m&aacute;ximo.</li>
<li>Tambi&eacute;n sabemos que $\max\{|A|, |B|\} \leq \frac{3n}{4}$.</li>
<li>La Llamada recursiva del &uacute;ltimo paso toma al
  m&aacute;ximo tiempo $T(\frac{3n}{4})$.</li>
</ul>
<p>
Entonces, para alguna constante $c$,
$$
T(n) = \left \{ \begin{array}{ll}
c, &\text{ si } n < 20 \\
T(\frac{n}{5} + T(\frac{3n}{4}) + cn, &\text{ si } n \geq 20.
\end{array} \right.
$$
Con inducci&oacute;n se llega a $T(n) \leq 20cn \in \mathcal{O}(n)$.
</p>
<h4>Programaci&oacute;n din&aacute;mica</h4>
<p>
En <strong>programaci&oacute;n din&aacute;mica</strong>, uno empieza a
construir la soluci&oacute;n desde las soluciones de los subproblemas
m&aacute;s peque&ntilde;os, guardando las soluciones en una forma
sistem&aacute;tica para construir soluciones a problemas
mayores. T&iacute;picamente las soluciones parciales est&aacute;n
guardadas en un arreglo para evitar a tener que solucionar un
subprobelma igual m&aacute;s tarde el la ejecuci&oacute;n del
algoritmo.  El algoritmo pseudo-polinomial que vimos para el problema
de la mochila es esencialmente un algoritmo de programaci&oacute;n
din&aacute;mica (PD). En general, la utilidad de PD est&aacute; en
problemas donde la soluci&oacute;n del problema completo contiene las
soluciones de los subproblemas &mdash; una situaci&oacute;n que ocurre
en algunos problemas de optimizaci&oacute;n.
</p>
<p>
Como un ejemplo, calculamos los coeficientes binomiales. Si uno
lo aplica de la manera <em>dividir y conquistar</em>, es necesario
volver a calcular varias veces algunos coeficientes peque&ntilde;os,
llegando a la complejidad asint&oacute;tica 
$$\Omega\left(\binom{n}{k}\right) = \Omega\left(\frac{2^n}{\sqrt{n}}\right).$$  
Por guardar las soluciones parciales, se llega a $\mathcal{O}(nk)$;
sin embargo, por guardarlas, la complejidad de espacio crece.
</p>
<p>
Las coeficientes binomiales forman el <em>tri&aacute;ngulo de
Pascal</em>:
</p>
<table border="1">
<tr><th rowspan="2">$n$</th><th colspan="9">$k$</th></tr>
<tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr>
<tr><th>0</th><td>1</td>
<td colspan="8">&nbsp;</td></tr>
<tr><th>1</th><td>1</td><td>1</td>
<td colspan="7">&nbsp;</td></tr>
<tr><th>2</th><td>1</td><td>2</td><td>1</td>
<td colspan="6">&nbsp;</td></tr>
<tr><th>3</th><td>1</td><td>3</td><td>3</td><td>1</td>
<td colspan="5">&nbsp;</td></tr>
<tr><th>4</th><td>1</td><td>4</td><td>6</td><td>4</td><td>1</td>
<td colspan="4">&nbsp;</td></tr>
<tr><th>5</th><td>1</td><td>5</td><td>10</td><td>10</td><td>5</td><td>1</td>
<td colspan="3">&nbsp;</td></tr>
<tr><th>6</th><td>1</td><td>6</td><td>15</td><td>20</td><td>15</td><td>6</td><td> 1</td>
<td colspan="2">&nbsp;</td></tr>
<tr><th>7</th><td>1</td><td>7</td><td>21</td><td>35</td><td>35</td><td>21</td><td>7</td><td> 1</td>
<td colspan="1">&nbsp;</td></tr>
<tr><th>8</th><td>1</td><td>8</td><td>28</td><td>56</td><td>70</td><td>56</td><td>28</td><td>8 </td><td>1</td>
</tr>
</table>
<p>
La <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/editdist.py">distancia
de edici&oacute;n</a> (ingl&eacute;s: edit distance) es una medida de
similitud de sucesiones de s&iacute;mbolos (o sea, palabras formadas
por un alfabeto). Se define como el <em>n&uacute;mero m&iacute;nimo de
operaciones de edici&oacute;n</em> que se necesita aplicar a palabra
$P$ para llegar a la palabra $Q$. Aplican $d(P,Q) = d(Q,P)$ y $d(P,P)
= 0$. Las operaciones son las siguientes:
</p>
<ul>
<li><strong>Insertar</strong> un s&iacute;mbolo en posici&oacute;n $i$.</li>
<li><strong>Eliminar</strong> un s&iacute;mbolo de posici&oacute;n $i$.</li>
<li><strong>Reemplazar</strong> el s&iacute;mbolo en posici&oacute;n $i$ con otro.</li>
</ul>
<p>
T&iacute;picamente todas las operaciones tienen el mismo costo (sea
  uno), aunque se puede dar diferentes costos a diferentes
  operaciones. Aplica la <em>desigualdad de tri&aacute;ngulo</em>
  $d(P,Q) \leq d(P,R) + d(R,Q)$ en el caso b&aacute;sico, pero existen
  variaciones de la medida que no lo cumplen. Se puede calcular por
  programaci&oacute;n din&aacute;mica:
</p>
<p>
Un ejemplo:
<table border="1">
<tr><td>&nbsp;</td><td>&nbsp;</td><td>D</td><td>I</td><td>F</td><td>I</td><td>C</td><td>I</td><td>L</td></tr>
<tr><td> </td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr><td>F</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr>
<tr><td>A</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>5</td><td>6</td></tr>
<tr><td>C</td><td>3</td><td>3</td><td>3</td><td>3</td><td>4</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td>I</td><td>4</td><td>4</td><td>3</td><td>4</td><td>3</td><td>4</td><td>3</td><td>4</td></tr>
<tr><td>L</td><td>5</td><td>5</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td></tr>
</table>
</div>
<div class="clase">
<h3>Ejemplos de tipos de algoritmos</h3>
<p>
Una soluci&oacute;n ingenua a un problema de optimizaci&oacute;n
combinatorial es hacer una lista completa de todas las soluciones
factibles y evaluar la funci&oacute;n objetivo para cada una,
eligiendo al final la soluci&oacute;n cual dio el mejor valor.  La
complejidad de ese tipo de soluci&oacute;n es <em>por lo menos</em>
$\Omega(|F|)$ donde $F$ es el conjunto de soluciones factibles.  El
n&uacute;mero de soluciones factibles suele ser algo como
$\Omega(2^n)$, por lo cual el algoritmo ingenuo tiene complejidad
asint&oacute;tica <strong>exponencial</strong>. Si uno tiene un
m&eacute;todo eficiente para generar en una manera ordenada soluciones
factibles y r&aacute;pidamente decidir s&iacute; o no procesarlos (en
el sentido de podar-buscar), no es imposible utilizar un algoritmo
exponencial.
</p>
<p>
Otra opci&oacute;n es buscar por soluciones <em>aproximadas</em>, o
sea, soluciones cerca de ser &oacute;ptima sin necesariamente serlo.
Una manera de aproximaci&oacute;n es utilizar <strong>m&eacute;todos
heur&iacute;sticos</strong>, donde uno aplica una regla simple para
elegir candidatos. Si uno siempre elije el candidatos que desde el
punto de vista de evaluaci&oacute;n local se ve el mejor, la
heur&iacute;stica es <strong>voraz</strong>.
</p>
<p>
Muchos problemas de optimizaci&oacute;n combinatorial consisten de una
parte de construcci&oacute;n de cualquier soluci&oacute;n
factible. Esta construcci&oacute;n tiene la misma complejidad que el
problema de decisi&oacute;n de la <em>existencia</em> de una
soluci&oacute;n factible. No es posible que sea m&aacute;s
f&aacute;cil solucionar el problema de optimizaci&oacute;n que el
problema de decisi&oacute;n a cual est&aacute; basado.
</p>
<p>
Como un ejemplo, buscamos encontrar un &aacute;rbol de expansi&oacute;n
m&iacute;nima en un grafo ponderado no dirigido. Para construir un
&aacute;rbol de expansi&oacute;n cualquiera &mdash; o sea, una soluci&oacute;n
factible &mdash; podemos empezar de cualquier v&eacute;rtice, elegir
una arista, y continuar al vecino indicado, asegurando al
a&ntilde;adir aristas que nunca regresamos a un v&eacute;rtice ya
visitado con anterioridad.  Logramos a encontrar la soluci&oacute;n
&oacute;ptima con una heur&iacute;stica voraz: siempre elige la arista
con menor peso para a&ntilde;adir en el &aacute;rbol que est&aacute;
bajo construcci&oacute;n.
</p>
<p>
En lo siguiente se presentan dos algoritmos, de Prim y de Kruskal, que
son el tema de la secci&oacute;n 13.2 de Grimaldi.
</p>
<h4>Algoritmo de Prim</h4>
<p>
Empezamos por incluir en el &aacute;rbol <strong>la arista de peso
  m&iacute;nimo</strong>. En cada paso, se elige entre los vecinos de
  los v&eacute;rtices ya incluidos aquel que se pueda a&ntilde;adir
  con el menor peso entre los candidatos. Se guarda el "costo" de
  a&ntilde;adir un v&eacute;rtice en un arreglo auxiliar $c[v]$ y
  asignamos $c[v] = \infty$ para los que no son vecinos de
  v&eacute;rtices ya marcados.
</p>
<p> Para saber cuales v&eacute;rtices ya est&aacute;n incluidos, se
  necesita una estructura de datos; con mont&iacute;culos de Fibonacci
  complejidad de $\mathcal{O}(m + n \log n)$.
</p>
<p>
En
la <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/prim.py">implementaci&oacute;n
ejemplo en Python</a> se usa una librer&iacute;a <a target="_blank"
href="https://docs.python.org/dev/library/copy.html">copy</a> para
crear una copia auxiliar del grafo que se pueda modificar durante el
algoritmo, quitando las aristas que ya han sido consideradas.
</p>
<h4>Algoritmo de Kruskal</h4>
<p>
Empezar a a&ntilde;adir aristas, de la menos pesada a la m&aacute;s
pesada, cuidando a no formar ciclos por marcar v&eacute;rtices al
haberlos tocado con una
arista. El <a href="https://github.com/satuelisa/DiscreteMath/blob/master/homework/kruskal.py">algoritmo
de Kruskal</a> termina cuando todos los v&eacute;rtices est&aacute;n
en el mismo &aacute;rbol. Su complejidad es $\mathcal{O}(m \log m) =
\mathcal{O}(m \log n)$.
</p>
<h4>&iquest;C&oacute;mo guiar la b&uacute;squeda?</h4>
<p>
En los algoritmos de optimizaci&oacute;n combinatorial que
eval&uacute;an propiedades de varios y posiblemente todos los
candidatos de soluci&oacute;n, es esencial saber "guiar" la
b&uacute;squeda de la soluci&oacute;n y evitar evaluar "candidatos
malos". Un ejemplo de ese tipo de t&eacute;cnica es el m&eacute;todo
<em>podar-buscar</em>. Algoritmos que avancen siempre
en el candidato <em>localmente &oacute;ptimo</em> se
llaman <strong>voraces</strong>.
</p>
<p>
En el m&eacute;todo de "vuelta atr&aacute;s" (ingl&eacute;s:
backtracking) se aumenta una soluci&oacute;n parcial utilizando
candidatos de aumento.  En cuanto una soluci&oacute;n est&aacute;
encontrada, el algoritmo vuelve a examinar un ramo de aumento donde no
todos los candidatos han sido examinados todav&iacute;a.
</p>
<p>
Cuando uno utiliza <strong>cotas</strong> para decidir cu&aacute;les
ramos dejar sin explorar, la t&eacute;cnica se
llama <em>ramificar-acotar</em> (ingl&eacute;s: branch and bound). Es
recomendable utilizar m&eacute;todos tipo ramificar-acotar solamente
en casos donde uno no conoce un algoritmo eficiente y no basta con una
aproximaci&oacute;n. Los ramos de la computaci&oacute;n consisten de
soluciones factibles distintas y la subrutina para encontrar una cota
(superior para maximizaci&oacute;n y inferior para
minimizaci&oacute;n) deber&iacute;a ser r&aacute;pida.  Normalmente el
recorrido del &aacute;rbol de soluciones factibles se hace
<strong>en profundidad</strong>. Cada hoja del &aacute;rbol
corresponde a una <em>soluci&oacute;n factible</em>, mientras los
v&eacute;rtices internos son las operaciones de aumento que construyen
las soluciones factibles. El algoritmo <em>tiene que recordar el mejor
resultado visto</em> para poder eliminar ramos que por el valor de su
cota no pueden contener soluciones mejores a la ya conocida.
</p>
<p>
En la versi&oacute;n de optimizaci&oacute;n del problema de viajante
TSP, se busca por el ciclo de menor costo/peso en un grafo
ponderado. En el caso general, podemos pensar que el grafo sea no
dirigido y completo. Utilizamos un m&eacute;todo tipo ramificar-acotar
para buscar la soluci&oacute;n &oacute;ptima. Suponemos que el orden
de procesamiento de las aristas es fijo.
</p>
<p>
El &aacute;rbol de soluciones consiste en decicir para cada uno de los
$\binom{n}{2}$ aristas del grafo s&iacute; o no est&aacute; incluida
en el ciclo. Para el largo $\mathcal{L}(R)$ de cualquier ruta $R$
aplica que $$\mathcal{L}(R) = \frac{1}{2} \displaystyle \sum_{i =
1}^n \left(\mathcal{L}(v_{i-1}, v_i) + \mathcal{L}(v_i,
v_{i+1})\right),$$ donde los v&eacute;rtices de la ruta han sido
numerados seg&uacute;n su orden de visita en la ruta as&iacute; que el
primer v&eacute;rtice tiene dos n&uacute;meros $v_1$ y $v_{n+1}$ y el
&uacute;ltimo se conoce como $v_n$ y $v_0$ para dar continuidad a la
ecuaci&oacute;n.
</p>
<p>
Para cualquier ruta $R$ el costo de la arista incidente a cada
v&eacute;rtice es por lo menos el costo de la arista m&aacute;s barata
incidente a ese v&eacute;rtice. Para la ruta m&aacute;s corta
$R_{\min}$ aplica que $\mathcal{L}(R_{\min}) \geq \frac{1}{2} \sum_{v
\in V}$ los largos de las dos aristas m&aacute;s baratas incidentes a
$v$. Al procesar la arista $\{v, w\}$, el paso "ramificar" es el
siguiente:
<ol>
<li>Si al excluir $\{v, w\}$ resultar&iacute;a que uno de los
  v&eacute;rtices $v$ o $w$ tenga menos que dos aristas incidentes
  para la ruta, ignoramos el ramo de excluirla.</li>
<li>Si al incluir $\{v, w\}$ resultar&iacute;a que uno de los
  v&eacute;rtices $v$ o $w$ tenga m&aacute;s que dos aristas
  incidentes para la ruta, ignoramos el ramo de inclusi&oacute;n.</li>
<li>Si al incluir $\{v, w\}$ se generar&iacute;a un ciclo en la ruta
  actua sin haber incluido todos los v&eacute;rtices todav&iacute;a,
  ignoramos el ramo de inclusi&oacute;n.</li>
</ol>
</p>
<p>
Despu&eacute;s de haber eliminado o inclu&iacute;do aristas
as&iacute;, computamos un nuevo valor de $R_{\min}$ para las
elecciones hechas y lo utilizamos como la cota inferior. Si ya
conocemos una soluci&oacute;n mejor a la cota asi obtenida, ignoramos
el ramo. Al cerrar un ramo, regresamos por el &aacute;rbol (de la
manera DFS) al nivel anterior que todav&iacute;a tiene ramos sin
considerar. Cuando ya no queda ninguno, el algoritmo termina.
</p>
<h4>Soluciones no-&oacute;ptimas</h4>
<p>
En situaciones donde todos los algoritmos conocidos son lentos, vale
la pena considerar la posilibidad de usar una soluci&oacute;n
aproximada, o sea, una soluci&oacute;n que tiene un valor de la
funci&oacute;n objetivo <em>cerca del valor &oacute;ptimo</em>, pero
no necesariamente el &oacute;ptimo mismo. Depende del &aacute;rea de
aplicaci&oacute;n s&iacute; o no se puede hacer esto
eficientemente. En muchos casos es posible llegar a una
soluci&oacute;n aproximada muy r&aacute;pidamente mientras encontrar
la soluci&oacute;n &oacute;ptima puede ser imposiblemente lento.
</p>
<p>
Un algoritmo de aproximaci&oacute;n puede ser determinista o no
determinista. Si el algoritmo de aproximaci&oacute;n <strong>no es
determinista</strong> y ejecuta muy r&aacute;pidamente, es
com&uacute;n <em>ejecutarlo varias veces</em> y elegir el mejor de las
soluciones aproximadas as&iacute; producidas. Un algoritmo de
aproximaci&oacute;n bien dise&ntilde;ado cuenta con un an&aacute;lisis
formal que muestra que la diferencia entre su soluci&oacute;n y la
soluci&oacute;n &oacute;ptima es de un
<em>factor constante</em>. Este factor se llama el <strong>factor de
aproximaci&oacute;n</strong>; este factor es $< 1$ para
maximizaci&oacute;n y $> 1$ para minimizaci&oacute;n. Depende de la
aplicaci&oacute;n qu&eacute; tan cerca deber&iacute;a ser la
soluci&oacute;n aproximada a la soluci&oacute;n &oacute;ptima.
</p>
<p>
El <em>valor extremo</em> del factor sobre el conjunto de todas las
instancias del problema es la <strong>tasa</strong>
o <strong>&iacute;ndice de aproximaci&oacute;n</strong>
(ingl&eacute;s: approximation ratio). Un algoritmo de
aproximaci&oacute;n tiene <strong>tasa constante</strong> si el valor
de la soluci&oacute;n encontrada es por m&aacute;ximo un
m&uacute;ltiple constante del valor &oacute;ptimo. Tambi&eacute;n
habr&aacute; que mostrar formalmente que el algoritmo de
aproximaci&oacute;n tiene complejidad polinomial. En el caso
de algoritmos de aproximaci&oacute;n probabilistas, basta con mostrar
que sea polinomial con alta probabilidad.
</p>
<p>
El <strong>problema de empaquetear a cajas</strong> (BIN PACKING) sirve de ejemplo:
<br>
<em>Entrada</em>: un conjunto finito de objetos $\Phi = \{\varphi_1,
\varphi_2 \ldots, \varphi_N\}$, cada uno con un tama&ntilde;o definido
$t(\varphi_i) \in \mathbb{R}$.
<br>
<em>Pregunta</em>: &iquest;C&oacute;mo empaquetear en cajas de
tama&ntilde;o fijo $T$ los objetos as&iacute; que $T \geq \max \{
t(\varphi_i) \mid \varphi_i \in \Phi\}$ y que el n&uacute;mero de cajas
utilizadas sea m&iacute;nima.</p>
<p>Este problema tambi&eacute;n es NP-completo.</p>
<p>
Un <em>algoritmo de aproximaci&oacute;n</em> para ello es el siguiente:
<ol>
<li>Ordenar las cajas en una fila.</li>
<li>Procesamos los objetos en orden.</li>
<li>Primero intentamos poner el objecto actualmente procesado en la
primera caja de la fila.</li>
<li>Si cabe, lo ponemos all&iacute;, y si no, intentamos
en la siguiente caja.</li>
<li>Iterando as&iacute; obtenemos alguna asignaci&oacute;n de objetos a cajas.</li>
</ol>
<p> Denotamos con $\text{OPT}(\Phi)$ el n&uacute;mero de cajas que
contienen <em>por lo menos un objeto</em> en la asignaci&oacute;n
&oacute;ptima. Se puede mostrar que el algoritmo de
aproximaci&oacute;n simple utiliza al m&aacute;ximo $\frac{17}{10}
\text{OPT}(\Phi) + 2$ cajas.  Esto significa que nunca alejamos a
m&aacute;s de 70% de la soluci&oacute;n &oacute;ptima.
</p>
<p>
Podemos mejorar a&uacute;n por ordenar los objetos as&iacute; que
intentamos primero el m&aacute;s grande y despu&eacute;s el segundo
m&aacute;s grande. Para este caso se puede mostrar que llegamos a
utilizar al m&aacute;ximo $\frac{11}{9} \text{OPT}(\Phi) + 4$ cajas, que nos
da una distancia m&aacute;xima de unos 22% del &oacute;ptimo.
</p>
</div>
<div class="clase">
<h3>Algoritmos de aproximaci&oacute;n</h3>
<p>
Una versi&oacute;n del TSP con los pesos involucra un grafo completo
ponderado con <em>distancias</em> entre los v&eacute;rtices $d(v, w)$
que cumplen con la <em>desigualdad de tri&aacute;ngulo</em> $ d(v, u)
\leq d(v, w) + d(w, u)$. Tambi&eacute;n es un problema NP-completo.
Un <em>algoritmo de aproximaci&oacute;n</em> es el siguiente:
<ol>
<li>Construye un &aacute;rbol de expansi&oacute;n m&iacute;nimo en
 tiempo $\mathcal{O}(\log n)$.</li>
<li>Elige un v&eacute;rtice de inicio cualquiera $v$.</li>
<li>Recorre el &aacute;rbol con DFS en tiempo $\mathcal{O}(m + n)$ e
imprime los v&eacute;rtices en
preorden.</li>
<li>Imprime $v$ en tiempo $\mathcal{O}(1)$.</li>
</ol>
</p>
<p>
El DFS recorre <em>cada arista del &aacute;rbol dos veces</em>;
podemos pensar en el recorrido como una ruta larga $R'$ que visita
cada v&eacute;rtice por lo menos una vez, pero varias v&eacute;rtices
m&aacute;s de una vez. "Cortamos" de la ruta larga $R'$ cualquier
visita a un v&eacute;rtice que ya ha sido visitado, as&iacute;
logrando el mismo efecto de imprimir los v&eacute;rtices en preorder.
Por la desigualdad de tri&aacute;ngulo, sabemos que la ruta cortada
$R$ no puede ser m&aacute;s cara que la ruta larga $R'$. El costo
total de $R'$ es dos veces el costo del &aacute;rbol de expansi&oacute;n
m&iacute;nimo.
</p>
<p> 
Para lograr a comparar el resultado con el &oacute;ptimo, hay que
analizar el &oacute;ptimo en t&eacute;rminos de &aacute;rboles
de expansi&oacute;n. Si eliminamos cualquier arista de la ruta &oacute;ptima
$R_{\text{OPT}}$, obtenemos un &aacute;rbol de expansi&oacute;n. El peso de este
&aacute;rbol es por lo menos el mismo que el peso de un &aacute;rbol
de expansi&oacute;n m&iacute;nimo $C$.  Entonces, si marcamos el costo de la
ruta $R$ con $c(R)$, hemos mostrado que necesariamente $c(R) \leq
c(R') = \leq 2C \leq 2c(R_{\text{OPT}})$.
</p>
<p>Como otro ejemplo, regresamos al problema MINCUT. Vamos a
considerar multigrafos, o sea, permitimos que entre un par de
v&eacute;rtices exista m&aacute;s que una arista en el grafo de
entrada $\mathcal{G}$. Considerando que un grafo simple es un caso
especial de un multigrafo, el resultado del algoritmo que presentamos
aplica igual a grafos simples.
</p>
<ul>
<li>MINCUT $\in$ P.</li>
<li>Estamos buscando un corte $C \subseteq V$ de $\mathcal{G}$.</li>
<li>La capacidad del corte es el n&uacute;mero de aristas que lo crucen.</li>
<li>Suponemos que la entrada $\mathcal{G}$ sea conexo.</li>
<li>Todo lo que mostramos aplicar&iacute;a tambi&eacute;n para grafos
  (simples o multigrafos) ponderados con pesos no negativos.</li>
</ul>
<p>Un algoritmo determinista es el siguiente:</p>
<ul>
<li>A trav&eacute;s de flujo m&aacute;ximo: $\mathcal{O}(nm \log (n^2/m))$.</li>
<li>Habr&iacute;a que repetirlo para considerar <em>todos los pares de
fuente-sumidero</em>.</li>
<li>Se puede demostrar que basta con $(n-1)$ repeticiones.</li>
<li>$\Longrightarrow$ MINCUT $\in \Omega(n^2 m)$.</li>
<li>Con unos trucos: MINCUT $\in \mathcal{O}(nm \log (n^2/m))$.</li>
<li>Grafos densos: $m \in \mathcal{O}(n^2)$.</li>
</ul>
<p>
Al contraer la arista $\{u, v\}$ reemplazamos los dos v&eacute;rtices
$u$ u $v$ por un v&eacute;rtice nuevo $w$.  La arista contra&iacute;da
desaparece, y para toda arista $\{s, u\}$ tal que $s \notin \{u, v\}$,
"movemos" la arista a apuntar a $w$ por reemplazarla por $\{s, w\}$.
Igualmente reemplazamos aristas $\{s, u\}$ por aristas $\{s, w\}$ para
todo $s \notin \{u, v\}$.
</p>
<img width="350" src="img/contract.png">
<p>
Si contraemos un conjunto $E' \subseteq E$, el resultado no depende
del orden de contracci&oacute;n.  Despu&eacute;s de las contracciones,
los v&eacute;rtices que quedan representan subgrafos conexos del grafo
original. Empezando con el grafo de entraga $\mathcal{G}$, si elegimos
iterativamente al azar entre las aristas presentes una para
contracci&oacute;n hasta que quedan s&oacute;lo dos v&eacute;rtices,
el n&uacute;mero de aristas en el multigrafo final entre esos dos
v&eacute;rtices corresponde a un corte de $\mathcal{G}$.
</p>
<p>
Al contraer la arista $\{u, v\}$, el nombre del conjunto combinado en
la estructura ser&aacute; $v$ y sus miembros son $u$ y $v$;
originalmente cada v&eacute;rtice tiene su propio conjunto. Entonces,
podemos imprimir los conjuntos $C$ y $V \setminus C$ que corresponden
a los dos v&eacute;rtices que quedan en la &uacute;ltima
iteraci&oacute;n.</p>
<ul>
<li>La elecci&oacute;n uniforme de una arista para contraer se puede
  lograr en $\mathcal{O}(n)$.</li>
<li>En cada iteraci&oacute;n eliminamos un v&eacute;rtice, por lo cual
  el algoritmo de contracci&oacute;n tiene complejidad
  cuadr&aacute;tica en $n$.</li>
<li>Lo que queda mostrar es que el corte as&iacute; producido sea el
m&iacute;nimo con una probabilidad no cero.</li>
<li>As&iacute; por repetir el algoritmo, podr&iacute;amos aumentar la
probabilidad de haber encontrado el corte m&iacute;nimo.</li>
<li>Si la capacidad del corte m&iacute;nimo es $k$, ning&uacute;n
v&eacute;rtice puede tener grado menor a $k$.</li>
<li>El n&uacute;mero de aristas satisface $m \geq \frac{1}{2}nk$ si
la capacidad del corte m&iacute;nimo es $k$.</li>
<li>La capacidad del corte m&iacute;nimo en $\mathcal{G}$
despu&eacute;s de la contracci&oacute;n de una arista es mayor o igual
a la capacidad del corte m&iacute;nimo en $\mathcal{G}$.</li>
</ul>
</div>
<div class="ejercicio">
  <h3 id="e5">Tarea 5</h3>
  <p><em>Los <a target="_blank"
      href="https://elisa.dyndns-web.com/teaching/mat/discretas/ejemplos/">ejemplos</a>
      sobre la tarea 5 forman parte de los siguientes materiales de apoyo:
      <ul>
	<li>video sobre las <a target="_blank"
	       href="https://youtu.be/Dh7YI4u_1AU">preguntas 1 y 2</a></li>
	<li>video sobre las <a target="_blank"
	       href="https://youtu.be/lJ0OiPKdcXg">preguntas 3 y 4</a></li>
	<li>video sobre la <a target="_blank"
	       href="https://youtu.be/ZTehJDpaqdU">pregunta 5.</a></li>
    </ul></em>      
  </p>
  <p>
    Pregunta 1: <em>An&aacute;lisis de algoritmos recursivos</em>
    &iquest;Cu&aacute;ntas llamadas a la
    rutina <span class="codevar">bbinaria</span> se necesita al buscar
    por el valor
    <span id="d5.valor">5</span> en un arreglo cuyo contenido son los
    enteros ordenados desde <span id="d5.desde">2</span>
    hasta <span id="d5.hasta">20</span> en pasos
    de <span id="d5.pasos">2</span>?
    <input type="text" id="r5.1" size="10" value="">
  </p>
    <span id="c5.1"></span>
  <p>Pregunta 2: <em>An&aacute;lisis de estructuras de recursivas</em>
    &iquest;Qu&eacute; es la altura m&iacute;nima posible de un
    &aacute;rbol binario lleno de <span id="d5.nodos">30</span>
    nodos?
  <input type="text" id="r5.2" size="10" value="">
  </p>
  <span id="c5.2"></span>
  <p>
    Pregunta 3: <em>&Aacute;rboles binarios</em>
    Agregando en el siguiente orden los
    elementos <span id="d5.arbol">18, 32, 12, 34, 15, 7, 21, 88, 16,
    56</span> al &aacute;rbol binario simple del c&oacute;digo
    ejemplo, &iquest;cu&aacute;ntas llamadas a la
    rutina <span class="codevar">ubicar</span> se realizan al buscar
    por el elemento <span id="d5.elemento">30</span> en el
    &aacute;rbol resultante?
  <input type="text" id="r5.3" size="10" value="">
  </p>
  <span id="c5.3"></span>
  <p>
    Pregunta 4: <em>Programaci&oacute;n din&aacute;mica</em>
    Si los costos de las operaciones de edici&oacute;n son
    <span id="d5.ins">2</span> por insertar,
    <span id="d5.eli">2</span> por eliminar y 
    <span id="d5.ree">1</span> por reemplazar,
    &iquest;qu&eacute; es la distancia de edici&oacute;n entre
    "s&aacute;bado" y "domingo"?
  <input type="text" id="r5.4" size="10" value="">
  </p>
  <span id="c5.4"></span>
  <p>
    Pregunta 5: <em>&Aacute;rboles de expansi&oacute;n m&iacute;nima</em>
						  
   Asignando un peso de <span id="d5.peso">3</span> a una arista
   desde <span id="d5.inicio">2</span>
   hasta <span id="d5.final">7</span> (sustituyendo el valor existente
   en el caso que haya) a la instancia del problema de &aacute;rbol de
   expansi&oacute;n m&iacute;nima, &iquest;cu&aacute;nto vale ahora el
   &oacute;ptimo?
  <input type="text" id="r5.5" size="10" value="">
  </p>
  <span id="c5.5"></span>
  <div class="calif" id="ce5">
    <span id="s5"></span>
    <span id="l5"></span>
</div>
  <h4>Preguntas de verificaci&oacute;n</h4>
  <p>
    <em>Discute lo siguiente con los compa&ntilde;eros y con la
      profesora hasta que est&eacute; todo claro. Conviene consultar
      el libro de texto (cap&iacute;tulos y secciones indicados en el
      material de la unidad en esta p&aacute;gina) y hasta buscar por
      videos en la web. Cuando ya no cabe duda, procede al proyecto
      individual.</em>
  </p>
  <p>
    Describe en palabras propias y dibujos de apoyo la forma de
    operaci&oacute;n de las siguientes estructuras de datos: arreglo, lista,
    pila, cola, &aacute;rbol binario.
  </p>
  <p>
    &iquest;Qu&eacute; es el prop&oacute;sito de algoritmos de b&uacute;squeda, algoritmos de
    recorrido y algoritmos de ordenamiento? Menciona ejemplos de los
    tres tipos de algoritmos.
  </p>
  <p>
    &iquest;Por qu&eacute; existen mecanismos para balancear &aacute;rboles binarios? &iquest;Por
    qu&eacute; no conviene llenarlas sin preocuparse del balance?
  </p>
  <p>
    &iquest;Qu&eacute; t&eacute;cnicas existen para el dise&ntilde;o de algoritmos? &iquest;Qu&eacute;
    aplicaciones pr&aacute;cticas puedes pensar para el c&aacute;lculo de distancias
    de edici&oacute;n y para la construcci&oacute;n de &aacute;rboles de expansi&oacute;n? &iquest;Por
    qu&eacute; a veces se usan algoritmos aproximados en luhgar de algoritmos
    exactos?
  </p>
  <p>
  </p>
</div>
<div class="clase">
<h4>Proyecto individual</h4>
<p>
Recuerda que al concluir las cinco tareas, toca iniciar
el <a href="proyecto.html">proyecto individual</A>. Consulta con la
profesora sobre tus ideas de temas para concretar los pasos. 
</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="pie">
 Actualizado el 21 de octubre del 2021.
<br>
  URL: https://elisa.dyndns-web.com/teaching/mat/discr/md.html
</div>
<script type="text/javascript" src="md.js"></script>
<script>
  MathJax = {
      tex: {
	  inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
  };
</script>
<script id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</div>
</body>
</html>
